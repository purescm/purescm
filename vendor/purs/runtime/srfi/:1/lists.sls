;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor/
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: %3a1/lists.sls
#!r6rs
;; Copyright 2010 Derick Eddington.  My MIT-style license is in the file named
;; LICENSE from the original collection this file is distributed with.
;;;;;; File header: %3a1/srfi-1-reference.scm
;;; SRFI-1 list-processing library                      -*- Scheme -*-
;;; Reference implementation
;;;
;;; Copyright (c) 1998, 1999 by Olin Shivers. You may do as you please with
;;; this code as long as you do not remove this copyright notice or
;;; hold me liable for its use. Please send bug reports to shivers@ai.mit.edu.
;;;     -Olin
(library (purs runtime srfi :1 lists)
  (export xcons make-list list-tabulate list-copy proper-list?
   circular-list? dotted-list? not-pair? null-list? list=
   circular-list length+ iota first second third fourth fifth
   sixth seventh eighth ninth tenth car+cdr take drop
   take-right drop-right take! drop-right! split-at split-at!
   last last-pair zip unzip1 unzip2 unzip3 unzip4 unzip5 count
   append! append-reverse append-reverse! concatenate
   concatenate! unfold fold pair-fold reduce unfold-right
   pair-fold-right reduce-right append-map append-map! map!
   pair-for-each filter-map map-in-order filter! partition!
   remove! find-tail any every list-index take-while drop-while
   take-while! span break span! break! delete delete!
   alist-cons alist-copy delete-duplicates delete-duplicates!
   alist-delete alist-delete! reverse! lset<= lset= lset-adjoin
   lset-union lset-intersection lset-difference lset-xor
   lset-diff+intersection lset-union! lset-intersection!
   lset-difference! lset-xor! lset-diff+intersection! append
   assq assv caaaar caaadr caaar caadar caaddr caadr caar
   cadaar cadadr cadar caddar cadddr caddr cadr car cdaaar
   cdaadr cdaar cdadar cdaddr cdadr cdar cddaar cddadr cddar
   cdddar cddddr cdddr cddr cdr cons cons* length list list-ref
   memq memv null? pair? reverse set-car! set-cdr! assoc filter
   find fold-right for-each map member partition remove)
  (import
    (rename
      (except (rnrs) find filter fold-right map partition remove)
      (assoc r6rs:assoc)
      (for-each r6rs:for-each)
      (member r6rs:member))
    (rnrs mutable-pairs) (purs runtime srfi :8 receive)
    (purs runtime srfi :23 error tricks) (for (purs runtime srfi private vanish) expand)
    (purs runtime srfi private check-arg) (purs runtime srfi private include))
  (let-syntax ([define (vanish-define define (cons*))])
    (SRFI-23-error->R6RS
      "(library (purs runtime srfi :1 lists))"
      (begin
        (define (xcons d a) (cons a d))
        (define make-list
          (case-lambda
            [(len) (make-list len #f)]
            [(len elt)
             (check-arg index? len make-list)
             (do ([i len (fx- i 1)] [ans '() (cons elt ans)])
                 ((fx<=? i 0) ans))]))
        (define (list-tabulate len proc)
          (check-arg index? len list-tabulate)
          (check-arg procedure? proc list-tabulate)
          (do ([i (fx- len 1) (fx- i 1)]
               [ans '() (cons (proc i) ans)])
              ((fx<? i 0) ans)))
        (define cons*
          (case-lambda
            [(first) first]
            [(first second) (cons first second)]
            [(first second third . rest)
             (cons
               first
               (cons
                 second
                 (let recur ([x third] [rest rest])
                   (if (pair? rest)
                       (cons x (recur (car rest) (cdr rest)))
                       x))))]))
        (define (list-copy lis)
          (let recur ([lis lis])
            (if (pair? lis) (cons (car lis) (recur (cdr lis))) lis)))
        (define iota
          (case-lambda
            [(count) (iota count 0 1)]
            [(count start) (iota count start 1)]
            [(count start step)
             (check-arg index? count iota)
             (check-arg number? start iota)
             (check-arg number? step iota)
             (let loop ([cur start] [n 0])
               (if (fx=? n count)
                   '()
                   (cons cur (loop (fx+ cur step) (fx+ 1 n)))))]))
        (define (circular-list val1 . vals)
          (let ([ans (cons val1 vals)])
            (set-cdr! (last-pair ans) ans)
            ans))
        (define (proper-list? x)
          (let lp ([x x] [lag x])
            (if (pair? x)
                (let ([x (cdr x)])
                  (if (pair? x)
                      (let ([x (cdr x)] [lag (cdr lag)])
                        (and (not (eq? x lag)) (lp x lag)))
                      (null? x)))
                (null? x))))
        (define (dotted-list? x)
          (let lp ([x x] [lag x])
            (if (pair? x)
                (let ([x (cdr x)])
                  (if (pair? x)
                      (let ([x (cdr x)] [lag (cdr lag)])
                        (and (not (eq? x lag)) (lp x lag)))
                      (not (null? x))))
                (not (null? x)))))
        (define (circular-list? x)
          (let lp ([x x] [lag x])
            (and (pair? x)
                 (let ([x (cdr x)])
                   (and (pair? x)
                        (let ([x (cdr x)] [lag (cdr lag)])
                          (or (eq? x lag) (lp x lag))))))))
        (define (not-pair? x) (not (pair? x)))
        (define (null-list? l)
          (cond
            [(pair? l) #f]
            [(null? l) #t]
            [else (error "null-list?: argument out of domain" l)]))
        (define list=
          (case-lambda
            [(elt=) #t]
            [(elt= list-a) #t]
            [(elt= list-a list-b)
             (or (eq? list-a list-b)
                 (let loop ([list-a list-a] [list-b list-b])
                   (if (null-list? list-a)
                       (null-list? list-b)
                       (and (not (null-list? list-b))
                            (elt= (car list-a) (car list-b))
                            (loop (cdr list-a) (cdr list-b))))))]
            [(elt= list-a list-b list-c . lists)
             (and (list= elt= list-a list-b)
                  (list= elt= list-b list-c)
                  (or (null? lists)
                      (let loop ([list-a list-c] [lists lists])
                        (let ([list-b (car lists)] [others (cdr lists)])
                          (and (list= elt= list-a list-b)
                               (or (null? others)
                                   (loop list-b others)))))))]))
        (define (length+ x)
          (let loop ([x x] [len 0])
            (if (null? x)
                len
                (if (fx>? len 20)
                    (let lp ([x (cdr x)] [lag x] [len (fx+ len 1)])
                      (if (pair? x)
                          (let ([x (cdr x)] [len (fx+ len 1)])
                            (if (pair? x)
                                (let ([x (cdr x)]
                                      [lag (cdr lag)]
                                      [len (fx+ len 1)])
                                  (and (not (eq? x lag)) (lp x lag len)))
                                len))
                          len))
                    (loop (cdr x) (fx+ len 1))))))
        (define (zip list1 . more-lists)
          (apply map list list1 more-lists))
        (define first car)
        (define second cadr)
        (define third caddr)
        (define fourth cadddr)
        (define (fifth x) (car (cddddr x)))
        (define (sixth x) (cadr (cddddr x)))
        (define (seventh x) (caddr (cddddr x)))
        (define (eighth x) (cadddr (cddddr x)))
        (define (ninth x) (car (cddddr (cddddr x))))
        (define (tenth x) (cadr (cddddr (cddddr x))))
        (define (car+cdr pair) (values (car pair) (cdr pair)))
        (define (take lis k)
          (check-arg fixnum? k take)
          (let recur ([lis lis] [k k])
            (if (zero? k)
                '()
                (cons (car lis) (recur (cdr lis) (- k 1))))))
        (define (drop lis k)
          (check-arg fixnum? k drop)
          (let iter ([lis lis] [k k])
            (if (zero? k) lis (iter (cdr lis) (- k 1)))))
        (define (take! lis k)
          (check-arg fixnum? k take!)
          (if (zero? k)
              '()
              (begin (set-cdr! (drop lis (- k 1)) '()) lis)))
        (define (take-right lis k)
          (check-arg fixnum? k take-right)
          (let lp ([lag lis] [lead (drop lis k)])
            (if (pair? lead) (lp (cdr lag) (cdr lead)) lag)))
        (define (drop-right lis k)
          (check-arg fixnum? k drop-right)
          (let recur ([lag lis] [lead (drop lis k)])
            (if (pair? lead)
                (cons (car lag) (recur (cdr lag) (cdr lead)))
                '())))
        (define (drop-right! lis k)
          (check-arg fixnum? k drop-right!)
          (let ([lead (drop lis k)])
            (if (pair? lead)
                (let lp ([lag lis] [lead (cdr lead)])
                  (if (pair? lead)
                      (lp (cdr lag) (cdr lead))
                      (begin (set-cdr! lag '()) lis)))
                '())))
        (define (split-at x k)
          (check-arg fixnum? k split-at)
          (let recur ([lis x] [k k])
            (if (zero? k)
                (values '() lis)
                (receive
                  (prefix suffix)
                  (recur (cdr lis) (- k 1))
                  (values (cons (car lis) prefix) suffix)))))
        (define (split-at! x k)
          (check-arg fixnum? k split-at!)
          (if (zero? k)
              (values '() x)
              (let* ([prev (drop x (- k 1))] [suffix (cdr prev)])
                (set-cdr! prev '())
                (values x suffix))))
        (define (last lis) (car (last-pair lis)))
        (define (last-pair lis)
          (check-arg pair? lis last-pair)
          (let lp ([lis lis])
            (let ([tail (cdr lis)]) (if (pair? tail) (lp tail) lis))))
        (define (unzip1 lis) (map car lis))
        (define (unzip2 lis)
          (let recur ([lis lis])
            (if (null-list? lis)
                (values lis lis)
                (let ([elt (car lis)])
                  (receive
                    (a b)
                    (recur (cdr lis))
                    (values (cons (car elt) a) (cons (cadr elt) b)))))))
        (define (unzip3 lis)
          (let recur ([lis lis])
            (if (null-list? lis)
                (values lis lis lis)
                (let ([elt (car lis)])
                  (receive
                    (a b c)
                    (recur (cdr lis))
                    (values
                      (cons (car elt) a)
                      (cons (cadr elt) b)
                      (cons (caddr elt) c)))))))
        (define (unzip4 lis)
          (let recur ([lis lis])
            (if (null-list? lis)
                (values lis lis lis lis)
                (let ([elt (car lis)])
                  (receive
                    (a b c d)
                    (recur (cdr lis))
                    (values
                      (cons (car elt) a)
                      (cons (cadr elt) b)
                      (cons (caddr elt) c)
                      (cons (cadddr elt) d)))))))
        (define (unzip5 lis)
          (let recur ([lis lis])
            (if (null-list? lis)
                (values lis lis lis lis lis)
                (let ([elt (car lis)])
                  (receive
                    (a b c d e)
                    (recur (cdr lis))
                    (values (cons (car elt) a) (cons (cadr elt) b)
                      (cons (caddr elt) c) (cons (cadddr elt) d)
                      (cons (car (cddddr elt)) e)))))))
        (define append!
          (case-lambda
            [() '()]
            [(lis1) lis1]
            [(lis1 lis2)
             (cond
               [(null? lis2) lis1]
               [(null? lis1) lis2]
               [else (set-cdr! (last-pair lis1) lis2) lis1])]
            [(lis1 lis2 lis3 . lists)
             (let ([append-2! (lambda (lis1 lis2)
                                (set-cdr! (last-pair lis1) lis2)
                                lis1)]
                   [lists (delete '() lists)])
               (if (null? lists)
                   (if (null? lis3)
                       (append! lis1 lis2)
                       (let* ([lis (if (null? lis2)
                                       lis3
                                       (append-2! lis2 lis3))]
                              [lis (if (null? lis1)
                                       lis
                                       (append-2! lis1 lis))])
                         lis))
                   (let* ([lis (let loop ([lis (car lists)]
                                          [lists (cdr lists)])
                                 (if (null? lists)
                                     lis
                                     (append-2!
                                       lis
                                       (loop (car lists) (cdr lists)))))]
                          [lis (if (null? lis3) lis (append-2! lis3 lis))]
                          [lis (if (null? lis2) lis (append-2! lis2 lis))]
                          [lis (if (null? lis1) lis (append-2! lis1 lis))])
                     lis)))]))
        (define (append-reverse rev-head tail)
          (let lp ([rev-head rev-head] [tail tail])
            (if (null-list? rev-head)
                tail
                (lp (cdr rev-head) (cons (car rev-head) tail)))))
        (define (append-reverse! rev-head tail)
          (let lp ([rev-head rev-head] [tail tail])
            (if (null-list? rev-head)
                tail
                (let ([next-rev (cdr rev-head)])
                  (set-cdr! rev-head tail)
                  (lp next-rev rev-head)))))
        (define (concatenate lists) (reduce-right append '() lists))
        (define (concatenate! lists)
          (reduce-right append! '() lists))
        (define (%cdrs lists)
          (let f ([ls lists])
            (if (pair? ls)
                (let ([x (car ls)])
                  (if (null? x) '() (cons (cdr x) (f (cdr ls)))))
                '())))
        (define (%cars+ lists last-elt)
          (let recur ([lists lists])
            (if (pair? lists)
                (cons (caar lists) (recur (cdr lists)))
                (list last-elt))))
        (define (%cars+cdrs lists)
          (let f ([ls lists])
            (if (pair? ls)
                (let ([x (car ls)])
                  (if (null-list? x)
                      (values '() '())
                      (receive
                        (cars cdrs)
                        (f (cdr ls))
                        (values (cons (car x) cars) (cons (cdr x) cdrs)))))
                (values '() '()))))
        (define (%cars+cdrs+ lists cars-final)
          (let f ([ls lists])
            (if (pair? ls)
                (let ([x (car ls)])
                  (if (null-list? x)
                      (values '() '())
                      (receive
                        (cars cdrs)
                        (f (cdr ls))
                        (values (cons (car x) cars) (cons (cdr x) cdrs)))))
                (values (list cars-final) '()))))
        (define (%cars+cdrs/no-test lists)
          (let recur ([lists lists])
            (if (pair? lists)
                (receive
                  (list other-lists)
                  (car+cdr lists)
                  (receive
                    (a d)
                    (car+cdr list)
                    (receive
                      (cars cdrs)
                      (recur other-lists)
                      (values (cons a cars) (cons d cdrs)))))
                (values '() '()))))
        (define count
          (case-lambda
            [(pred list1)
             (check-arg procedure? pred count)
             (let lp ([lis list1] [i 0])
               (if (null-list? lis)
                   i
                   (lp (cdr lis) (if (pred (car lis)) (fx+ i 1) i))))]
            [(pred list1 . lists)
             (check-arg procedure? pred count)
             (let lp ([list1 list1] [lists lists] [i 0])
               (if (null-list? list1)
                   i
                   (receive
                     (as ds)
                     (%cars+cdrs lists)
                     (if (null? as)
                         i
                         (lp (cdr list1)
                             ds
                             (if (apply pred (car list1) as)
                                 (fx+ i 1)
                                 i))))))]))
        (define unfold-right
          (case-lambda
            [(p f g seed) (unfold-right p f g seed '())]
            [(p f g seed tail)
             (check-arg procedure? p unfold-right)
             (check-arg procedure? f unfold-right)
             (check-arg procedure? g unfold-right)
             (let lp ([seed seed] [ans tail])
               (if (p seed) ans (lp (g seed) (cons (f seed) ans))))]))
        (define unfold
          (case-lambda
            [(p f g seed)
             (check-arg procedure? p unfold)
             (check-arg procedure? f unfold)
             (check-arg procedure? g unfold)
             (let recur ([seed seed])
               (if (p seed) '() (cons (f seed) (recur (g seed)))))]
            [(p f g seed tail-gen)
             (check-arg procedure? p unfold)
             (check-arg procedure? f unfold)
             (check-arg procedure? g unfold)
             (let recur ([seed seed])
               (if (p seed)
                   (tail-gen seed)
                   (cons (f seed) (recur (g seed)))))]))
        (define fold
          (case-lambda
            [(kons knil lis1)
             (check-arg procedure? kons fold)
             (let lp ([lis lis1] [ans knil])
               (if (null-list? lis)
                   ans
                   (lp (cdr lis) (kons (car lis) ans))))]
            [(kons knil lis1 lis2)
             (check-arg procedure? kons fold)
             (let lp ([lis1 lis1] [lis2 lis2] [ans knil])
               (if (or (null-list? lis1) (null-list? lis2))
                   ans
                   (lp (cdr lis1)
                       (cdr lis2)
                       (kons (car lis1) (car lis2) ans))))]
            [(kons knil . lists)
             (check-arg procedure? kons fold)
             (let lp ([lists lists] [ans knil])
               (receive
                 (cars+ans cdrs)
                 (%cars+cdrs+ lists ans)
                 (if (null? cars+ans)
                     ans
                     (lp cdrs (apply kons cars+ans)))))]))
        (define fold-right
          (case-lambda
            [(kons knil lis1)
             (check-arg procedure? kons fold-right)
             (let recur ([lis lis1])
               (if (null-list? lis)
                   knil
                   (kons (car lis) (recur (cdr lis)))))]
            [(kons knil lis1 lis2)
             (check-arg procedure? kons fold-right)
             (let recur ([lis1 lis1] [lis2 lis2])
               (if (or (null-list? lis1) (null-list? lis2))
                   knil
                   (kons
                     (car lis1)
                     (car lis2)
                     (recur (cdr lis1) (cdr lis2)))))]
            [(kons knil . lists)
             (check-arg procedure? kons fold-right)
             (let recur ([lists lists])
               (let ([cdrs (%cdrs lists)])
                 (if (null? cdrs)
                     knil
                     (apply kons (%cars+ lists (recur cdrs))))))]))
        (define pair-fold-right
          (case-lambda
            [(f zero lis1)
             (check-arg procedure? f pair-fold-right)
             (let recur ([lis lis1])
               (if (null-list? lis) zero (f lis (recur (cdr lis)))))]
            [(f zero lis1 lis2 . lists)
             (check-arg procedure? f pair-fold-right)
             (let recur ([lis1 lis1] [lis2 lis2] [lists lists])
               (if (or (null-list? lis1) (null-list? lis2))
                   zero
                   (let ([cdrs (%cdrs lists)])
                     (if (null? cdrs)
                         zero
                         (apply
                           f
                           lis1
                           lis2
                           (append!
                             lists
                             (list
                               (recur (cdr lis1) (cdr lis2) cdrs))))))))]))
        (define pair-fold
          (case-lambda
            [(f zero lis1)
             (check-arg procedure? f pair-fold)
             (let lp ([lis lis1] [ans zero])
               (if (null? lis)
                   ans
                   (let ([tail (cdr lis)]) (lp tail (f lis ans)))))]
            [(f zero lis1 lis2 . lists)
             (check-arg procedure? f pair-fold)
             (let lp ([lis1 lis1] [lis2 lis2] [lists lists] [ans zero])
               (if (or (null-list? lis1) (null-list? lis2))
                   ans
                   (let ([tails (%cdrs lists)])
                     (if (null? tails)
                         ans
                         (lp (cdr lis1)
                             (cdr lis2)
                             tails
                             (apply
                               f
                               lis1
                               lis2
                               (append! lists (list ans))))))))]))
        (define (reduce f ridentity lis)
          (check-arg procedure? f reduce)
          (if (null-list? lis)
              ridentity
              (fold f (car lis) (cdr lis))))
        (define (reduce-right f ridentity lis)
          (check-arg procedure? f reduce-right)
          (if (null-list? lis)
              ridentity
              (let recur ([head (car lis)] [lis (cdr lis)])
                (if (pair? lis)
                    (f head (recur (car lis) (cdr lis)))
                    head))))
        (define append-map
          (case-lambda
            [(f lis1) (really-append-map append-map append f lis1)]
            [(f lis1 lis2)
             (really-append-map append-map append f lis1 lis2)]
            [(f lis1 lis2 . lists)
             (really-append-map append-map append f lis1 lis2 lists)]))
        (define append-map!
          (case-lambda
            [(f lis1) (really-append-map append-map! append! f lis1)]
            [(f lis1 lis2)
             (really-append-map append-map! append! f lis1 lis2)]
            [(f lis1 lis2 . lists)
             (really-append-map append-map! append! f lis1 lis2 lists)]))
        (define really-append-map
          (case-lambda
            [(who appender f lis1)
             (check-arg procedure? f who)
             (if (null-list? lis1)
                 '()
                 (let recur ([elt (car lis1)] [rest (cdr lis1)])
                   (let ([vals (f elt)])
                     (if (null-list? rest)
                         vals
                         (appender vals (recur (car rest) (cdr rest)))))))]
            [(who appender f lis1 lis2)
             (check-arg procedure? f who)
             (if (or (null-list? lis1) (null-list? lis2))
                 '()
                 (let recur ([lis1 lis1] [lis2 lis2])
                   (let ([vals (f (car lis1) (car lis2))]
                         [lis1 (cdr lis1)]
                         [lis2 (cdr lis2)])
                     (if (or (null-list? lis1) (null-list? lis2))
                         vals
                         (appender vals (recur lis1 lis2))))))]
            [(who appender f lis1 lis2 lists)
             (check-arg procedure? f who)
             (if (or (null-list? lis1) (null-list? lis2))
                 '()
                 (receive
                   (cars cdrs)
                   (%cars+cdrs lists)
                   (if (null? cars)
                       '()
                       (let recur ([lis1 lis1]
                                   [lis2 lis2]
                                   [cars cars]
                                   [cdrs cdrs])
                         (let ([vals (apply f (car lis1) (car lis2) cars)]
                               [lis1 (cdr lis1)]
                               [lis2 (cdr lis2)])
                           (if (or (null-list? lis1) (null-list? lis2))
                               vals
                               (receive
                                 (cars2 cdrs2)
                                 (%cars+cdrs cdrs)
                                 (if (null? cars2)
                                     vals
                                     (appender
                                       vals
                                       (recur
                                         lis1
                                         lis2
                                         cars2
                                         cdrs2))))))))))]))
        (define pair-for-each
          (case-lambda
            [(proc lis1)
             (check-arg procedure? proc pair-for-each)
             (let lp ([lis lis1])
               (if (not (null-list? lis))
                   (let ([tail (cdr lis)]) (proc lis) (lp tail))))]
            [(proc lis1 lis2 . lists)
             (check-arg procedure? proc pair-for-each)
             (let lp ([lis1 lis1] [lis2 lis2] [lists lists])
               (if (and (pair? lis1) (pair? lis2))
                   (let ([tails (%cdrs lists)])
                     (if (pair? tails)
                         (begin
                           (apply proc lis1 lis2 lists)
                           (lp (cdr lis1) (cdr lis2) tails))))))]))
        (define map!
          (case-lambda
            [(f lis1)
             (check-arg procedure? f map!)
             (let lp ([lis1 lis1])
               (when (not (null-list? lis1))
                 (set-car! lis1 (f (car lis1)))
                 (lp (cdr lis1))))
             lis1]
            [(f lis1 lis2)
             (check-arg procedure? f map!)
             (let lp ([lis1 lis1] [lis2 lis2])
               (when (not (null-list? lis1))
                 (set-car! lis1 (f (car lis1) (car lis2)))
                 (lp (cdr lis1) (cdr lis2))))
             lis1]
            [(f lis1 lis2 lis3 . lists)
             (check-arg procedure? f map!)
             (let lp ([lis1 lis1] [lis2 lis2] [lis3 lis3] [lists lists])
               (when (not (null-list? lis1))
                 (receive
                   (heads tails)
                   (%cars+cdrs/no-test lists)
                   (set-car!
                     lis1
                     (apply f (car lis1) (car lis2) (car lis3) heads))
                   (lp (cdr lis1) (cdr lis2) (cdr lis3) tails))))
             lis1]))
        (define filter-map
          (case-lambda
            [(f lis1)
             (check-arg procedure? f filter-map)
             (let recur ([lis lis1])
               (if (null-list? lis)
                   '()
                   (let ([tail (recur (cdr lis))])
                     (cond
                       [(f (car lis)) => (lambda (x) (cons x tail))]
                       [else tail]))))]
            [(f lis1 . lists)
             (check-arg procedure? f filter-map)
             (let recur ([lis1 lis1] [lists lists])
               (if (null-list? lis1)
                   '()
                   (receive
                     (cars cdrs)
                     (%cars+cdrs lists)
                     (if (pair? cars)
                         (cond
                           [(apply f (car lis1) cars) =>
                            (lambda (x) (cons x (recur (cdr lis1) cdrs)))]
                           [else (recur (cdr lis1) cdrs)])
                         '()))))]))
        (define map-in-order
          (case-lambda
            [(f lis1)
             (check-arg procedure? f map-in-order)
             (let recur ([lis lis1])
               (if (null-list? lis)
                   lis
                   (let ([tail (cdr lis)] [x (f (car lis))])
                     (cons x (recur tail)))))]
            [(f lis1 lis2)
             (check-arg procedure? f map-in-order)
             (let recur ([lis1 lis1] [lis2 lis2])
               (if (and (pair? lis1) (pair? lis2))
                   (let ([x (f (car lis1) (car lis2))])
                     (cons x (recur (cdr lis1) (cdr lis2))))
                   '()))]
            [(f lis1 lis2 . lists)
             (check-arg procedure? f map-in-order)
             (let recur ([lis1 lis1] [lis2 lis2] [lists lists])
               (receive
                 (cars cdrs)
                 (%cars+cdrs lists)
                 (if (and (pair? lis1) (pair? lis2) (pair? cars))
                     (let ([x (apply f (car lis1) (car lis2) cars)])
                       (cons x (recur (cdr lis1) (cdr lis2) cdrs)))
                     '())))]))
        (define map map-in-order)
        (define for-each
          (case-lambda
            [(f lis1) (r6rs:for-each f lis1)]
            [(f lis1 lis2)
             (check-arg procedure? f for-each)
             (let recur ([lis1 lis1] [lis2 lis2])
               (unless (or (null-list? lis1) (null-list? lis2))
                 (f (car lis1) (car lis2))
                 (recur (cdr lis1) (cdr lis2))))]
            [(f lis1 lis2 . lists)
             (check-arg procedure? f for-each)
             (let recur ([lis1 lis1] [lis2 lis2] [lists lists])
               (unless (or (null-list? lis1) (null-list? lis2))
                 (receive
                   (cars cdrs)
                   (%cars+cdrs lists)
                   (when (pair? cars)
                     (apply f (car lis1) (car lis2) cars)
                     (recur (cdr lis1) (cdr lis2) cdrs)))))]))
        (define (filter pred lis)
          (check-arg procedure? pred filter)
          (let recur ([lis lis])
            (if (null-list? lis)
                lis
                (let ([head (car lis)] [tail (cdr lis)])
                  (if (pred head)
                      (let ([new-tail (recur tail)])
                        (if (eq? tail new-tail) lis (cons head new-tail)))
                      (recur tail))))))
        (define (filter! pred lis)
          (check-arg procedure? pred filter!)
          (let lp ([ans lis])
            (cond
              [(null-list? ans) ans]
              [(not (pred (car ans))) (lp (cdr ans))]
              [else
               (letrec ([scan-in (lambda (prev lis)
                                   (if (pair? lis)
                                       (if (pred (car lis))
                                           (scan-in lis (cdr lis))
                                           (scan-out prev (cdr lis)))))]
                        [scan-out (lambda (prev lis)
                                    (let lp ([lis lis])
                                      (if (pair? lis)
                                          (if (pred (car lis))
                                              (begin
                                                (set-cdr! prev lis)
                                                (scan-in lis (cdr lis)))
                                              (lp (cdr lis)))
                                          (set-cdr! prev lis))))])
                 (scan-in ans (cdr ans))
                 ans)])))
        (define (partition pred lis)
          (check-arg procedure? pred partition)
          (let recur ([lis lis])
            (if (null-list? lis)
                (values lis lis)
                (let ([elt (car lis)] [tail (cdr lis)])
                  (receive
                    (in out)
                    (recur tail)
                    (if (pred elt)
                        (values (if (pair? out) (cons elt in) lis) out)
                        (values
                          in
                          (if (pair? in) (cons elt out) lis))))))))
        (define (partition! pred lis)
          (check-arg procedure? pred partition!)
          (if (null-list? lis)
              (values lis lis)
              (letrec ([scan-in (lambda (in-prev out-prev lis)
                                  (let lp ([in-prev in-prev] [lis lis])
                                    (if (pair? lis)
                                        (if (pred (car lis))
                                            (lp lis (cdr lis))
                                            (begin
                                              (set-cdr! out-prev lis)
                                              (scan-out
                                                in-prev
                                                lis
                                                (cdr lis))))
                                        (set-cdr! out-prev lis))))]
                       [scan-out (lambda (in-prev out-prev lis)
                                   (let lp ([out-prev out-prev] [lis lis])
                                     (if (pair? lis)
                                         (if (pred (car lis))
                                             (begin
                                               (set-cdr! in-prev lis)
                                               (scan-in
                                                 lis
                                                 out-prev
                                                 (cdr lis)))
                                             (lp lis (cdr lis)))
                                         (set-cdr! in-prev lis))))])
                (if (pred (car lis))
                    (let lp ([prev-l lis] [l (cdr lis)])
                      (cond
                        [(not (pair? l)) (values lis l)]
                        [(pred (car l)) (lp l (cdr l))]
                        [else (scan-out prev-l l (cdr l)) (values lis l)]))
                    (let lp ([prev-l lis] [l (cdr lis)])
                      (cond
                        [(not (pair? l)) (values l lis)]
                        [(pred (car l))
                         (scan-in l prev-l (cdr l))
                         (values l lis)]
                        [else (lp l (cdr l))]))))))
        (define (remove pred lis)
          (check-arg procedure? pred remove)
          (let recur ([lis lis])
            (if (null-list? lis)
                lis
                (let ([head (car lis)] [tail (cdr lis)])
                  (if (not (pred head))
                      (let ([new-tail (recur tail)])
                        (if (eq? tail new-tail) lis (cons head new-tail)))
                      (recur tail))))))
        (define (remove! pred lis)
          (check-arg procedure? pred remove!)
          (let lp ([ans lis])
            (cond
              [(null-list? ans) ans]
              [(pred (car ans)) (lp (cdr ans))]
              [else
               (letrec ([scan-in (lambda (prev lis)
                                   (if (pair? lis)
                                       (if (not (pred (car lis)))
                                           (scan-in lis (cdr lis))
                                           (scan-out prev (cdr lis)))))]
                        [scan-out (lambda (prev lis)
                                    (let lp ([lis lis])
                                      (if (pair? lis)
                                          (if (not (pred (car lis)))
                                              (begin
                                                (set-cdr! prev lis)
                                                (scan-in lis (cdr lis)))
                                              (lp (cdr lis)))
                                          (set-cdr! prev lis))))])
                 (scan-in ans (cdr ans))
                 ans)])))
        (define delete
          (case-lambda
            [(x lis) (delete x lis equal?)]
            [(x lis elt=)
             (let recur ([lis lis])
               (if (null-list? lis)
                   lis
                   (let ([head (car lis)] [tail (cdr lis)])
                     (if (not (elt= x head))
                         (let ([new-tail (recur tail)])
                           (if (eq? tail new-tail)
                               lis
                               (cons head new-tail)))
                         (recur tail)))))]))
        (define delete!
          (case-lambda
            [(x lis) (delete! x lis equal?)]
            [(x lis elt=)
             (let lp ([ans lis])
               (cond
                 [(null-list? ans) ans]
                 [(elt= x (car ans)) (lp (cdr ans))]
                 [else
                  (letrec ([scan-in (lambda (prev lis)
                                      (if (pair? lis)
                                          (if (not (elt= x (car lis)))
                                              (scan-in lis (cdr lis))
                                              (scan-out prev (cdr lis)))))]
                           [scan-out (lambda (prev lis)
                                       (let lp ([lis lis])
                                         (if (pair? lis)
                                             (if (not (elt= x (car lis)))
                                                 (begin
                                                   (set-cdr! prev lis)
                                                   (scan-in lis (cdr lis)))
                                                 (lp (cdr lis)))
                                             (set-cdr! prev lis))))])
                    (scan-in ans (cdr ans))
                    ans)]))]))
        (define member
          (case-lambda
            [(x lis) (r6rs:member x lis)]
            [(x lis elt=)
             (let lp ([lis lis])
               (and (not (null-list? lis))
                    (if (elt= x (car lis)) lis (lp (cdr lis)))))]))
        (define delete-duplicates
          (case-lambda
            [(lis) (delete-duplicates lis equal?)]
            [(lis elt=)
             (check-arg procedure? elt= delete-duplicates)
             (let recur ([lis lis])
               (if (null-list? lis)
                   lis
                   (let* ([x (car lis)]
                          [tail (cdr lis)]
                          [new-tail (recur (delete x tail elt=))])
                     (if (eq? tail new-tail) lis (cons x new-tail)))))]))
        (define delete-duplicates!
          (case-lambda
            [(lis) (delete-duplicates! lis equal?)]
            [(lis elt=)
             (check-arg procedure? elt= delete-duplicates!)
             (let recur ([lis lis])
               (if (null-list? lis)
                   lis
                   (let* ([x (car lis)]
                          [tail (cdr lis)]
                          [new-tail (recur (delete! x tail elt=))])
                     (if (not (eq? tail new-tail)) (set-cdr! lis new-tail))
                     lis)))]))
        (define assoc
          (case-lambda
            [(x lis) (r6rs:assoc x lis)]
            [(x lis elt=)
             (let loop ([lis lis])
               (if (pair? lis)
                   (let ([entry (car lis)])
                     (if (elt= x (car entry)) entry (loop (cdr lis))))
                   #f))]))
        (define (alist-cons key datum alist)
          (cons (cons key datum) alist))
        (define (alist-copy alist)
          (map (lambda (elt) (cons (car elt) (cdr elt))) alist))
        (define alist-delete
          (case-lambda
            [(key alist)
             (remove (lambda (elt) (equal? key (car elt))) alist)]
            [(key alist elt=)
             (remove (lambda (elt) (elt= key (car elt))) alist)]))
        (define alist-delete!
          (case-lambda
            [(key alist)
             (remove! (lambda (elt) (equal? key (car elt))) alist)]
            [(key alist elt=)
             (remove! (lambda (elt) (elt= key (car elt))) alist)]))
        (define (find pred lis)
          (check-arg procedure? pred find)
          (let loop ([lis lis])
            (if (pair? lis)
                (let ([head (car lis)])
                  (if (pred head) head (loop (cdr lis))))
                #f)))
        (define (find-tail pred lis)
          (check-arg procedure? pred find-tail)
          (let lp ([lis lis])
            (and (not (null-list? lis))
                 (if (pred (car lis)) lis (lp (cdr lis))))))
        (define (take-while pred lis)
          (check-arg procedure? pred take-while)
          (let recur ([lis lis])
            (if (null-list? lis)
                '()
                (let ([x (car lis)])
                  (if (pred x) (cons x (recur (cdr lis))) '())))))
        (define (drop-while pred lis)
          (check-arg procedure? pred drop-while)
          (let lp ([lis lis])
            (if (null-list? lis)
                '()
                (if (pred (car lis)) (lp (cdr lis)) lis))))
        (define (take-while! pred lis)
          (check-arg procedure? pred take-while!)
          (if (or (null-list? lis) (not (pred (car lis))))
              '()
              (begin
                (let lp ([prev lis] [rest (cdr lis)])
                  (if (pair? rest)
                      (let ([x (car rest)])
                        (if (pred x)
                            (lp rest (cdr rest))
                            (set-cdr! prev '())))))
                lis)))
        (define (span pred lis)
          (check-arg procedure? pred span)
          (let recur ([lis lis])
            (if (null-list? lis)
                (values '() '())
                (let ([x (car lis)])
                  (if (pred x)
                      (receive
                        (prefix suffix)
                        (recur (cdr lis))
                        (values (cons x prefix) suffix))
                      (values '() lis))))))
        (define (span! pred lis)
          (check-arg procedure? pred span!)
          (if (or (null-list? lis) (not (pred (car lis))))
              (values '() lis)
              (let ([suffix (let lp ([prev lis] [rest (cdr lis)])
                              (if (null-list? rest)
                                  rest
                                  (let ([x (car rest)])
                                    (if (pred x)
                                        (lp rest (cdr rest))
                                        (begin
                                          (set-cdr! prev '())
                                          rest)))))])
                (values lis suffix))))
        (define (break pred lis)
          (check-arg procedure? pred break)
          (let recur ([lis lis])
            (if (null-list? lis)
                (values '() '())
                (let ([x (car lis)])
                  (if (not (pred x))
                      (receive
                        (prefix suffix)
                        (recur (cdr lis))
                        (values (cons x prefix) suffix))
                      (values '() lis))))))
        (define (break! pred lis)
          (check-arg procedure? pred break!)
          (if (or (null-list? lis) (pred (car lis)))
              (values '() lis)
              (let ([suffix (let lp ([prev lis] [rest (cdr lis)])
                              (if (null-list? rest)
                                  rest
                                  (let ([x (car rest)])
                                    (if (not (pred x))
                                        (lp rest (cdr rest))
                                        (begin
                                          (set-cdr! prev '())
                                          rest)))))])
                (values lis suffix))))
        (define any
          (case-lambda
            [(pred lis1)
             (check-arg procedure? pred any)
             (and (not (null-list? lis1))
                  (let loop ([head (car lis1)] [tail (cdr lis1)])
                    (if (null-list? tail)
                        (pred head)
                        (or (pred head) (loop (car tail) (cdr tail))))))]
            [(pred lis1 lis2)
             (check-arg procedure? pred any)
             (and (not (null-list? lis1))
                  (not (null-list? lis2))
                  (let loop ([head1 (car lis1)]
                             [tail1 (cdr lis1)]
                             [head2 (car lis2)]
                             [tail2 (cdr lis2)])
                    (if (or (null-list? tail1) (null-list? tail2))
                        (pred head1 head2)
                        (or (pred head1 head2)
                            (loop
                              (car tail1)
                              (cdr tail1)
                              (car tail2)
                              (cdr tail2))))))]
            [(pred lis1 lis2 . lists)
             (check-arg procedure? pred any)
             (and (not (null-list? lis1))
                  (not (null-list? lis2))
                  (receive
                    (heads tails)
                    (%cars+cdrs lists)
                    (and (pair? heads)
                         (let loop ([head1 (car lis1)]
                                    [tail1 (cdr lis1)]
                                    [head2 (car lis2)]
                                    [tail2 (cdr lis2)]
                                    [heads heads]
                                    [tails tails])
                           (if (or (null-list? tail1) (null-list? tail2))
                               (apply pred head1 head2 heads)
                               (receive
                                 (next-heads next-tails)
                                 (%cars+cdrs tails)
                                 (if (null? next-tails)
                                     (apply pred head1 head2 heads)
                                     (or (apply pred head1 head2 heads)
                                         (loop (car tail1) (cdr tail1)
                                           (car tail2) (cdr tail2)
                                           next-heads
                                           next-tails)))))))))]))
        (define every
          (case-lambda
            [(pred lis1)
             (check-arg procedure? pred every)
             (or (null-list? lis1)
                 (let loop ([head (car lis1)] [tail (cdr lis1)])
                   (if (null-list? tail)
                       (pred head)
                       (and (pred head) (loop (car tail) (cdr tail))))))]
            [(pred lis1 lis2)
             (check-arg procedure? pred every)
             (or (null-list? lis1)
                 (null-list? lis2)
                 (let loop ([head1 (car lis1)]
                            [tail1 (cdr lis1)]
                            [head2 (car lis2)]
                            [tail2 (cdr lis2)])
                   (if (or (null-list? tail1) (null-list? tail2))
                       (pred head1 head2)
                       (and (pred head1 head2)
                            (loop
                              (car tail1)
                              (cdr tail1)
                              (car tail2)
                              (cdr tail2))))))]
            [(pred lis1 lis2 . lists)
             (check-arg procedure? pred every)
             (or (null-list? lis1)
                 (null-list? lis2)
                 (receive
                   (heads tails)
                   (%cars+cdrs lists)
                   (or (not (pair? heads))
                       (let loop ([head1 (car lis1)]
                                  [tail1 (cdr lis1)]
                                  [head2 (car lis2)]
                                  [tail2 (cdr lis2)]
                                  [heads heads]
                                  [tails tails])
                         (if (or (null-list? tail1) (null-list? tail2))
                             (apply pred head1 head2 heads)
                             (receive
                               (next-heads next-tails)
                               (%cars+cdrs tails)
                               (if (null? next-tails)
                                   (apply pred head1 head2 heads)
                                   (and (apply pred head1 head2 heads)
                                        (loop (car tail1) (cdr tail1)
                                          (car tail2) (cdr tail2)
                                          next-heads next-tails)))))))))]))
        (define list-index
          (case-lambda
            [(pred lis1)
             (check-arg procedure? pred list-index)
             (let loop ([lis lis1] [n 0])
               (and (not (null-list? lis))
                    (if (pred (car lis)) n (loop (cdr lis) (fx+ n 1)))))]
            [(pred lis1 lis2)
             (check-arg procedure? pred list-index)
             (let loop ([lis1 lis1] [lis2 lis2] [n 0])
               (and (not (or (null-list? lis1) (null-list? lis2)))
                    (if (pred (car lis1) (car lis2))
                        n
                        (loop (cdr lis1) (cdr lis2) (fx+ n 1)))))]
            [(pred lis1 lis2 lis3 . lists)
             (check-arg procedure? pred list-index)
             (let loop ([lis1 lis1]
                        [lis2 lis2]
                        [lis3 lis3]
                        [lists lists]
                        [n 0])
               (and (not (or (null-list? lis1)
                             (null-list? lis2)
                             (null-list? lis3)))
                    (receive
                      (heads tails)
                      (%cars+cdrs lists)
                      (and (not (null? heads))
                           (if (apply pred (car lis1) (car lis2) (car lis3)
                                 heads)
                               n
                               (loop (cdr lis1) (cdr lis2) (cdr lis3) tails
                                 (fx+ n 1)))))))]))
        (define (reverse! lis)
          (let lp ([lis lis] [ans '()])
            (if (null-list? lis)
                ans
                (let ([tail (cdr lis)])
                  (set-cdr! lis ans)
                  (lp tail lis)))))
        (define (%lset2<= = lis1 lis2)
          (every (lambda (x) (member x lis2 =)) lis1))
        (define lset<=
          (case-lambda
            [(=) (check-arg procedure? = lset<=) #t]
            [(= lis1) (check-arg procedure? = lset<=) #t]
            [(= lis1 lis2)
             (check-arg procedure? = lset<=)
             (or (eq? lis1 lis2) (%lset2<= = lis1 lis2))]
            [(= lis1 lis2 lis3 . lists)
             (check-arg procedure? = lset<=)
             (and (or (eq? lis1 lis2) (%lset2<= = lis1 lis2))
                  (or (eq? lis2 lis3) (%lset2<= = lis2 lis3))
                  (or (null? lists)
                      (let loop ([lis1 lis3]
                                 [lis2 (car lists)]
                                 [lists (cdr lists)])
                        (and (or (eq? lis1 lis2) (%lset2<= = lis1 lis2))
                             (or (null? lists)
                                 (loop
                                   lis2
                                   (car lists)
                                   (cdr lists)))))))]))
        (define lset=
          (case-lambda
            [(=) (check-arg procedure? = lset=) #t]
            [(= lis1) (check-arg procedure? = lset=) #t]
            [(= lis1 lis2)
             (check-arg procedure? = lset=)
             (or (eq? lis1 lis2)
                 (and (%lset2<= = lis1 lis2) (%lset2<= = lis2 lis1)))]
            [(= lis1 lis2 lis3 . lists)
             (check-arg procedure? = lset=)
             (and (or (eq? lis1 lis2)
                      (and (%lset2<= = lis1 lis2) (%lset2<= = lis2 lis1)))
                  (or (eq? lis2 lis3)
                      (and (%lset2<= = lis2 lis3) (%lset2<= = lis3 lis2)))
                  (or (null? lists)
                      (let loop ([lis1 lis3]
                                 [lis2 (car lists)]
                                 [lists (cdr lists)])
                        (and (or (eq? lis1 lis2)
                                 (and (%lset2<= = lis1 lis2)
                                      (%lset2<= = lis2 lis1)))
                             (or (null? lists)
                                 (loop
                                   lis2
                                   (car lists)
                                   (cdr lists)))))))]))
        (define lset-adjoin
          (case-lambda
            [(= lis) lis]
            [(= lis elt)
             (check-arg procedure? = lset-adjoin)
             (if (member elt lis) lis (cons elt lis))]
            [(= lis elt1 elt2)
             (check-arg procedure? = lset-adjoin)
             (let* ([lis (if (member elt1 lis) lis (cons elt1 lis))]
                    [lis (if (member elt2 lis) lis (cons elt2 lis))])
               lis)]
            [(= lis elt1 elt2 elt3 . elts)
             (check-arg procedure? = lset-adjoin)
             (let* ([lis (if (member elt1 lis) lis (cons elt1 lis))]
                    [lis (if (member elt2 lis) lis (cons elt2 lis))]
                    [lis (if (member elt3 lis) lis (cons elt3 lis))])
               (if (null? elts)
                   lis
                   (fold
                     (lambda (elt ans)
                       (if (member elt ans =) ans (cons elt ans)))
                     lis
                     elts)))]))
        (define lset-union
          (let ([lset-union-2 (lambda (= lis1 lis2)
                                (cond
                                  [(null? lis1) lis2]
                                  [(null? lis2) lis1]
                                  [(eq? lis1 lis2) lis1]
                                  [else
                                   (fold
                                     (lambda (elt ans)
                                       (if (member elt ans =)
                                           ans
                                           (cons elt ans)))
                                     lis1
                                     lis2)]))])
            (case-lambda
              [(=) (check-arg procedure? = lset-union) '()]
              [(= lis1) (check-arg procedure? = lset-union) lis1]
              [(= lis1 lis2)
               (check-arg procedure? = lset-union)
               (lset-union-2 = lis1 lis2)]
              [(= lis1 lis2 lis3 . lists)
               (check-arg procedure? = lset-union)
               (let* ([lis (lset-union-2 = lis1 lis2)]
                      [lis (lset-union-2 = lis lis3)])
                 (if (null? lists)
                     lis
                     (fold
                       (lambda (lis2 lis1) (lset-union-2 = lis1 lis2))
                       lis
                       lists)))])))
        (define lset-union!
          (let ([lset-union-2! (lambda (= lis1 lis2)
                                 (cond
                                   [(null? lis1) lis2]
                                   [(null? lis2) lis1]
                                   [(eq? lis1 lis2) lis1]
                                   [else
                                    (pair-fold
                                      (lambda (pair ans)
                                        (let ([elt (car pair)])
                                          (if (member elt ans =)
                                              ans
                                              (begin
                                                (set-cdr! pair ans)
                                                pair))))
                                      lis1
                                      lis2)]))])
            (case-lambda
              [(=) (check-arg procedure? = lset-union!) '()]
              [(= lis1) (check-arg procedure? = lset-union!) lis1]
              [(= lis1 lis2)
               (check-arg procedure? = lset-union!)
               (lset-union-2! = lis1 lis2)]
              [(= lis1 lis2 lis3 . lists)
               (check-arg procedure? = lset-union!)
               (let* ([lis (lset-union-2! = lis1 lis2)]
                      [lis (lset-union-2! = lis lis3)])
                 (if (null? lists)
                     lis
                     (fold
                       (lambda (lis1 lis2) (lset-union-2! = lis1 lis2))
                       lis
                       lists)))])))
        (define lset-intersection
          (case-lambda
            [(= lis1) (check-arg procedure? = lset-intersection) lis1]
            [(= lis1 lis2)
             (check-arg procedure? = lset-intersection)
             (cond
               [(or (null-list? lis1) (eq? lis1 lis2)) lis1]
               [(null-list? lis2) lis2]
               [else (filter (lambda (x) (member x lis2 =)) lis1)])]
            [(= lis1 lis2 lis3 . lists)
             (check-arg procedure? = lset-intersection)
             (cond
               [(or (null-list? lis1)
                    (null-list? lis2)
                    (null-list? lis3)
                    (any null-list? lists))
                '()]
               [(eq? lis2 lis1)
                (if (eq? lis3 lis1)
                    (apply lset-intersection = lis1 lists)
                    (apply lset-intersection = lis1 lis3 lists))]
               [(or (eq? lis3 lis1) (eq? lis3 lis2))
                (apply lset-intersection = lis1 lis2 lists)]
               [else
                (let* ([lists (remove
                                (lambda (lis)
                                  (or (eq? lis lis1)
                                      (eq? lis lis2)
                                      (eq? lis lis3)))
                                lists)])
                  (filter
                    (lambda (x)
                      (and (member x lis2 =)
                           (member x lis3 =)
                           (every (lambda (lis) (member x lis =)) lists)))
                    lis1))])]))
        (define lset-intersection!
          (case-lambda
            [(= lis1) (check-arg procedure? = lset-intersection!) lis1]
            [(= lis1 lis2)
             (check-arg procedure? = lset-intersection!)
             (cond
               [(or (null-list? lis2) (eq? lis1 lis2)) lis1]
               [(null-list? lis1) lis2]
               [else (filter! (lambda (x) (member x lis2 =)) lis1)])]
            [(= lis1 lis2 lis3 . lists)
             (check-arg procedure? = lset-intersection!)
             (cond
               [(or (null-list? lis1)
                    (null-list? lis2)
                    (null-list? lis3)
                    (any null-list? lists))
                '()]
               [(eq? lis2 lis1)
                (if (eq? lis3 lis1)
                    (apply lset-intersection! = lis1 lists)
                    (apply lset-intersection! = lis1 lis3 lists))]
               [(or (eq? lis3 lis1) (eq? lis3 lis2))
                (apply lset-intersection! = lis1 lis2 lists)]
               [else
                (let ([lists (remove
                               (lambda (lis)
                                 (or (eq? lis lis1)
                                     (eq? lis lis2)
                                     (eq? lis lis3)))
                               lists)])
                  (filter!
                    (lambda (x)
                      (and (member x lis2 =)
                           (member x lis3 =)
                           (every (lambda (lis) (member x lis =)) lists)))
                    lis1))])]))
        (define lset-difference
          (case-lambda
            [(= lis1) (check-arg procedure? = lset-difference) lis1]
            [(= lis1 lis2)
             (check-arg procedure? = lset-difference)
             (cond
               [(null-list? lis2) lis1]
               [(or (null-list? lis1) (eq? lis1 lis2)) '()]
               [else (filter (lambda (x) (not (member x lis2 =))) lis1)])]
            [(= lis1 lis2 lis3 . lists)
             (check-arg procedure? = lset-difference)
             (cond
               [(or (null-list? lis1)
                    (eq? lis1 lis2)
                    (eq? lis1 lis3)
                    (memq lis1 lists))
                '()]
               [(null? lis2)
                (if (null? lis3)
                    (apply lset-difference lis1 lists)
                    (apply lset-difference lis1 lis3 lists))]
               [(or (null? lis3) (eq? lis3 lis2))
                (apply lset-difference lis1 lis2 lists)]
               [else
                (let ([lists (remove
                               (lambda (lis)
                                 (or (null? lis)
                                     (eq? lis lis2)
                                     (eq? lis lis3)))
                               lists)])
                  (filter
                    (lambda (x)
                      (and (not (member x lis2 =))
                           (not (member x lis3 =))
                           (every
                             (lambda (lis) (not (member x lis =)))
                             lists)))
                    lis1))])]))
        (define lset-difference!
          (case-lambda
            [(= lis1) (check-arg procedure? = lset-difference!) lis1]
            [(= lis1 lis2)
             (check-arg procedure? = lset-difference!)
             (cond
               [(null-list? lis2) lis1]
               [(or (null-list? lis1) (eq? lis1 lis2)) '()]
               [else (filter! (lambda (x) (not (member x lis2 =))) lis1)])]
            [(= lis1 lis2 lis3 . lists)
             (check-arg procedure? = lset-difference!)
             (cond
               [(or (null-list? lis1)
                    (eq? lis1 lis2)
                    (eq? lis1 lis3)
                    (memq lis1 lists))
                '()]
               [(null? lis2)
                (if (null? lis3)
                    (apply lset-difference lis1 lists)
                    (apply lset-difference lis1 lis3 lists))]
               [(or (null? lis3) (eq? lis3 lis2))
                (apply lset-difference lis1 lis2 lists)]
               [else
                (let ([lists (remove
                               (lambda (lis)
                                 (or (null? lis)
                                     (eq? lis lis2)
                                     (eq? lis lis3)))
                               lists)])
                  (filter!
                    (lambda (x)
                      (and (not (member x lis2 =))
                           (every
                             (lambda (lis) (not (member x lis =)))
                             lists)))
                    lis1))])]))
        (define lset-xor
          (let ([lset-xor-2 (lambda (= b a)
                              (receive
                                (a-b a-int-b)
                                (lset-diff+intersection = a b)
                                (cond
                                  [(null? a-b) (lset-difference = b a)]
                                  [(null? a-int-b) (append b a)]
                                  [else
                                   (fold
                                     (lambda (xb ans)
                                       (if (member xb a-int-b =)
                                           ans
                                           (cons xb ans)))
                                     a-b
                                     b)])))])
            (case-lambda
              [(=) (check-arg procedure? = lset-xor) '()]
              [(= a) (check-arg procedure? = lset-xor) a]
              [(= a b)
               (check-arg procedure? = lset-xor)
               (lset-xor-2 = b a)]
              [(= a b c . lists)
               (check-arg procedure? = lset-xor)
               (let* ([lis (lset-xor-2 = b a)] [lis (lset-xor-2 = c lis)])
                 (if (null? lists)
                     lis
                     (fold
                       (lambda (b a) (lset-xor-2 = b a))
                       lis
                       lists)))])))
        (define lset-xor!
          (let ([lset-xor-2! (lambda (= b a)
                               (receive
                                 (a-b a-int-b)
                                 (lset-diff+intersection! = a b)
                                 (cond
                                   [(null? a-b) (lset-difference! = b a)]
                                   [(null? a-int-b) (append! b a)]
                                   [else
                                    (pair-fold
                                      (lambda (b-pair ans)
                                        (if (member (car b-pair) a-int-b =)
                                            ans
                                            (begin
                                              (set-cdr! b-pair ans)
                                              b-pair)))
                                      a-b
                                      b)])))])
            (case-lambda
              [(=) (check-arg procedure? = lset-xor!) '()]
              [(= a) (check-arg procedure? = lset-xor!) a]
              [(= a b)
               (check-arg procedure? = lset-xor!)
               (lset-xor-2! = b a)]
              [(= a b c . lists)
               (check-arg procedure? = lset-xor!)
               (let* ([lis (lset-xor-2! = b a)]
                      [lis (lset-xor-2! = c lis)])
                 (if (null? lists)
                     lis
                     (fold
                       (lambda (b a) (lset-xor-2! = b a))
                       lis
                       lists)))])))
        (define lset-diff+intersection
          (case-lambda
            [(= lis1)
             (check-arg procedure? = lset-diff+intersection)
             (values lis1 '())]
            [(= lis1 lis2)
             (check-arg procedure? = lset-diff+intersection)
             (cond
               [(or (null-list? lis1) (eq? lis1 lis2)) (values '() lis1)]
               [(null-list? lis2) (values lis1 '())]
               [else
                (partition
                  (lambda (elt) (not (member elt lis2 =)))
                  lis1)])]
            [(= lis1 lis2 lis3 . lists)
             (check-arg procedure? = lset-diff+intersection)
             (cond
               [(or (null-list? lis1)
                    (eq? lis1 lis2)
                    (eq? lis1 lis3)
                    (memq lis1 lists))
                (values '() lis1)]
               [(null-list? lis2)
                (if (null-list? lis3)
                    (apply lset-diff+intersection = lis1 lists)
                    (apply lset-diff+intersection = lis1 lis3 lists))]
               [(or (null-list? lis3) (eq? lis3 lis2))
                (apply lset-diff+intersection = lis1 lis2 lists)]
               [else
                (let ([lists (remove
                               (lambda (lis)
                                 (or (null? lis)
                                     (eq? lis lis2)
                                     (eq? lis lis3)))
                               lists)])
                  (partition
                    (lambda (elt)
                      (not (or (member elt lis2 =)
                               (member elt lis3 =)
                               (any (lambda (lis) (member elt lis =))
                                    lists))))
                    lis1))])]))
        (define lset-diff+intersection!
          (case-lambda
            [(= lis1)
             (check-arg procedure? = lset-diff+intersection!)
             (values lis1 '())]
            [(= lis1 lis2)
             (check-arg procedure? = lset-diff+intersection!)
             (cond
               [(or (null-list? lis1) (eq? lis1 lis2)) (values '() lis1)]
               [(null-list? lis2) (values lis1 '())]
               [else
                (partition!
                  (lambda (elt) (not (member elt lis2 =)))
                  lis1)])]
            [(= lis1 lis2 lis3 . lists)
             (check-arg procedure? = lset-diff+intersection!)
             (cond
               [(or (null-list? lis1)
                    (eq? lis1 lis2)
                    (eq? lis1 lis3)
                    (memq lis1 lists))
                (values '() lis1)]
               [(null-list? lis2)
                (if (null-list? lis3)
                    (apply lset-diff+intersection! = lis1 lists)
                    (apply lset-diff+intersection! = lis1 lis3 lists))]
               [(or (null-list? lis3) (eq? lis3 lis2))
                (apply lset-diff+intersection = lis1 lis2 lists)]
               [else
                (let ([lists (remove
                               (lambda (lis)
                                 (or (null? lis)
                                     (eq? lis lis2)
                                     (eq? lis lis3)))
                               lists)])
                  (partition!
                    (lambda (elt)
                      (not (or (member elt lis2 =)
                               (member elt lis3 =)
                               (any (lambda (lis) (member elt lis =))
                                    lists))))
                    lis1))])]))))))
