;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor/
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: %3a158/generators-and-accumulators.sls
;;;;;; File header: %3a158/srfi-158-impl.scm
;; reference implementation from: https://github.com/scheme-requests-for-implementation/srfi-158
(library (purs runtime srfi :158 generators-and-accumulators)
  (export generator circular-generator make-iota-generator
   make-range-generator make-coroutine-generator
   list->generator vector->generator reverse-vector->generator
   string->generator bytevector->generator
   make-for-each-generator make-unfold-generator gcons* gappend
   gflatten ggroup gmerge gmap gcombine gfilter gremove
   gstate-filter gtake gdrop gtake-while gdrop-while gdelete
   gdelete-neighbor-dups gindex gselect generator->list
   generator->reverse-list generator->vector generator->vector!
   generator->string generator-fold generator-for-each
   generator-map->list generator-find generator-count
   generator-any generator-every generator-unfold
   make-accumulator count-accumulator list-accumulator
   reverse-list-accumulator vector-accumulator
   reverse-vector-accumulator vector-accumulator!
   string-accumulator bytevector-accumulator
   bytevector-accumulator! sum-accumulator product-accumulator)
  (import (rnrs) (only (purs runtime srfi :1) make-list)
    (only (chezscheme) call/1cc) (purs runtime srfi private include)
    (purs runtime srfi private define-values))
  (begin
    (define (any pred ls)
      (if (null? (cdr ls))
          (pred (car ls))
          ((lambda (x) (if x x (any pred (cdr ls))))
            (pred (car ls)))))
    (define (list->bytevector list)
      (let ([vec (make-bytevector (length list) 0)])
        (let loop ([i 0] [list list])
          (if (null? list)
              vec
              (begin
                (bytevector-u8-set! vec i (car list))
                (loop (+ i 1) (cdr list)))))))
    (define (generator . args)
      (lambda ()
        (if (null? args)
            (eof-object)
            (let ([next (car args)]) (set! args (cdr args)) next))))
    (define (circular-generator . args)
      (let ([base-args args])
        (lambda ()
          (when (null? args) (set! args base-args))
          (let ([next (car args)]) (set! args (cdr args)) next))))
    (define make-iota-generator
      (case-lambda
        [(count) (make-iota-generator count 0 1)]
        [(count start) (make-iota-generator count start 1)]
        [(count start step) (make-iota count start step)]))
    (define (make-iota count start step)
      (lambda ()
        (cond
          [(<= count 0) (eof-object)]
          [else
           (let ([result start])
             (set! count (- count 1))
             (set! start (+ start step))
             result)])))
    (define make-range-generator
      (case-lambda
        [(start end) (make-range-generator start end 1)]
        [(start) (make-infinite-range-generator start)]
        [(start end step)
         (set! start (- (+ start step) step))
         (lambda ()
           (if (< start end)
               (let ([v start]) (set! start (+ start step)) v)
               (eof-object)))]))
    (define (make-infinite-range-generator start)
      (lambda ()
        (let ([result start]) (set! start (+ start 1)) result)))
    (define (make-coroutine-generator proc)
      (define return #f)
      (define resume #f)
      (define yield
        (lambda (v)
          (call/cc (lambda (r) (set! resume r) (return v)))))
      (lambda ()
        (call/1cc
          (lambda (cc)
            (set! return cc)
            (if resume
                (resume (if #f #f))
                (begin
                  (proc yield)
                  (set! resume (lambda (v) (return (eof-object))))
                  (return (eof-object))))))))
    (define (list->generator lst)
      (lambda ()
        (if (null? lst)
            (eof-object)
            (let ([next (car lst)]) (set! lst (cdr lst)) next))))
    (define vector->generator
      (case-lambda
        [(vec) (vector->generator vec 0 (vector-length vec))]
        [(vec start)
         (vector->generator vec start (vector-length vec))]
        [(vec start end)
         (lambda ()
           (if (>= start end)
               (eof-object)
               (let ([next (vector-ref vec start)])
                 (set! start (+ start 1))
                 next)))]))
    (define reverse-vector->generator
      (case-lambda
        [(vec)
         (reverse-vector->generator vec 0 (vector-length vec))]
        [(vec start)
         (reverse-vector->generator vec start (vector-length vec))]
        [(vec start end)
         (lambda ()
           (if (>= start end)
               (eof-object)
               (let ([next (vector-ref vec (- end 1))])
                 (set! end (- end 1))
                 next)))]))
    (define string->generator
      (case-lambda
        [(str) (string->generator str 0 (string-length str))]
        [(str start)
         (string->generator str start (string-length str))]
        [(str start end)
         (lambda ()
           (if (>= start end)
               (eof-object)
               (let ([next (string-ref str start)])
                 (set! start (+ start 1))
                 next)))]))
    (define bytevector->generator
      (case-lambda
        [(str)
         (bytevector->generator str 0 (bytevector-length str))]
        [(str start)
         (bytevector->generator str start (bytevector-length str))]
        [(str start end)
         (lambda ()
           (if (>= start end)
               (eof-object)
               (let ([next (bytevector-u8-ref str start)])
                 (set! start (+ start 1))
                 next)))]))
    (define (make-for-each-generator for-each obj)
      (make-coroutine-generator
        (lambda (yield) (for-each yield obj))))
    (define (make-unfold-generator stop? mapper successor seed)
      (make-coroutine-generator
        (lambda (yield)
          (let loop ([s seed])
            (if (stop? s)
                (if #f #f)
                (begin (yield (mapper s)) (loop (successor s))))))))
    (define (gcons* . args)
      (lambda ()
        (if (null? args)
            (eof-object)
            (if (= (length args) 1)
                ((car args))
                (let ([v (car args)]) (set! args (cdr args)) v)))))
    (define (gappend . args)
      (lambda ()
        (if (null? args)
            (eof-object)
            (let loop ([v ((car args))])
              (if (eof-object? v)
                  (begin
                    (set! args (cdr args))
                    (if (null? args) (eof-object) (loop ((car args)))))
                  v)))))
    (define (gflatten gen)
      (let ([state '()])
        (lambda ()
          (if (null? state) (set! state (gen)))
          (if (eof-object? state)
              state
              (let ([obj (car state)]) (set! state (cdr state)) obj)))))
    (define ggroup
      (case-lambda
        [(gen k) (simple-ggroup gen k)]
        [(gen k padding)
         (padded-ggroup (simple-ggroup gen k) k padding)]))
    (define (simple-ggroup gen k)
      (lambda ()
        (let loop ([item (gen)] [result '()] [count (- k 1)])
          (if (eof-object? item)
              (if (null? result) item (reverse result))
              (if (= count 0)
                  (reverse (cons item result))
                  (loop (gen) (cons item result) (- count 1)))))))
    (define (padded-ggroup gen k padding)
      (lambda ()
        (let ([item (gen)])
          (if (eof-object? item)
              item
              (let ([len (length item)])
                (if (= len k)
                    item
                    (append item (make-list (- k len) padding))))))))
    (define gmerge
      (case-lambda
        [(<) (error #f "wrong number of arguments for gmerge")]
        [(< gen) gen]
        [(< genleft genright)
         (let ([left (genleft)] [right (genright)])
           (lambda ()
             (cond
               [(and (eof-object? left) (eof-object? right)) left]
               [(eof-object? left)
                (let ([obj right]) (set! right (genright)) obj)]
               [(eof-object? right)
                (let ([obj left]) (set! left (genleft)) obj)]
               [(< right left)
                (let ([obj right]) (set! right (genright)) obj)]
               [else (let ([obj left]) (set! left (genleft)) obj)])))]
        [(< . gens)
         (apply
           gmerge
           <
           (let loop ([gens gens] [gs '()])
             (cond
               [(null? gens) (reverse gs)]
               [(null? (cdr gens)) (reverse (cons (car gens) gs))]
               [else
                (loop
                  (cddr gens)
                  (cons (gmerge < (car gens) (cadr gens)) gs))])))]))
    (define gmap
      (case-lambda
        [(proc) (error #f "wrong number of arguments for gmap")]
        [(proc gen)
         (lambda ()
           (let ([item (gen)])
             (if (eof-object? item) item (proc item))))]
        [(proc . gens)
         (lambda ()
           (let ([items (map (lambda (x) (x)) gens)])
             (if (any eof-object? items)
                 (eof-object)
                 (apply proc items))))]))
    (define (gcombine proc seed . gens)
      (lambda ()
        (define items (map (lambda (x) (x)) gens))
        (if (any eof-object? items)
            (eof-object)
            (let ()
              (define-values (value newseed)
                (apply proc (append items (list seed))))
              (set! seed newseed)
              value))))
    (define (gfilter pred gen)
      (lambda ()
        (let loop ()
          (let ([next (gen)])
            (if (or (eof-object? next) (pred next)) next (loop))))))
    (define (gstate-filter proc seed gen)
      (let ([state seed])
        (lambda ()
          (let loop ([item (gen)])
            (if (eof-object? item)
                item
                (let-values ([(yes newstate) (proc item state)])
                  (set! state newstate)
                  (if yes item (loop (gen)))))))))
    (define (gremove pred gen)
      (gfilter (lambda (v) (not (pred v))) gen))
    (define gtake
      (case-lambda
        [(gen k) (gtake gen k (eof-object))]
        [(gen k padding)
         (define (%gtake gen k)
           (lambda ()
             (if (zero? k) (eof-object) (begin (set! k (- k 1)) (gen)))))
         (%gtake (gappend gen (lambda () padding)) k)]))
    (define (gdrop gen k)
      (lambda () (do () ((<= k 0)) (set! k (- k 1)) (gen)) (gen)))
    (define (gdrop-while pred gen)
      (define found #f)
      (lambda ()
        (let loop ()
          (let ([val (gen)])
            (cond
              [found val]
              [(and (not (eof-object? val)) (pred val)) (loop)]
              [else (set! found #t) val])))))
    (define (gtake-while pred gen)
      (lambda ()
        (let ([next (gen)])
          (if (eof-object? next)
              next
              (if (pred next)
                  next
                  (begin (set! gen (generator)) (gen)))))))
    (define gdelete
      (case-lambda
        [(item gen) (gdelete item gen equal?)]
        [(item gen ==)
         (lambda ()
           (let loop ([v (gen)])
             (cond
               [(eof-object? v) (eof-object)]
               [(== item v) (loop (gen))]
               [else v])))]))
    (define gdelete-neighbor-dups
      (case-lambda
        [(gen) (gdelete-neighbor-dups gen equal?)]
        [(gen ==)
         (define firsttime #t)
         (define prev #f)
         (lambda ()
           (if firsttime
               (begin (set! firsttime #f) (set! prev (gen)) prev)
               (let loop ([v (gen)])
                 (cond
                   [(eof-object? v) v]
                   [(== prev v) (loop (gen))]
                   [else (set! prev v) v]))))]))
    (define (gindex value-gen index-gen)
      (let ([done? #f] [count 0])
        (lambda ()
          (if done?
              (eof-object)
              (let loop ([value (value-gen)] [index (index-gen)])
                (cond
                  [(or (eof-object? value) (eof-object? index))
                   (set! done? #t)
                   (eof-object)]
                  [(= index count) (set! count (+ count 1)) value]
                  [else
                   (set! count (+ count 1))
                   (loop (value-gen) index)]))))))
    (define (gselect value-gen truth-gen)
      (let ([done? #f])
        (lambda ()
          (if done?
              (eof-object)
              (let loop ([value (value-gen)] [truth (truth-gen)])
                (cond
                  [(or (eof-object? value) (eof-object? truth))
                   (set! done? #t)
                   (eof-object)]
                  [truth value]
                  [else (loop (value-gen) (truth-gen))]))))))
    (define generator->list
      (case-lambda
        [(gen n) (generator->list (gtake gen n))]
        [(gen) (reverse (generator->reverse-list gen))]))
    (define generator->reverse-list
      (case-lambda
        [(gen n) (generator->reverse-list (gtake gen n))]
        [(gen) (generator-fold cons '() gen)]))
    (define generator->vector
      (case-lambda
        [(gen) (list->vector (generator->list gen))]
        [(gen n) (list->vector (generator->list gen n))]))
    (define (generator->vector! vector at gen)
      (let loop ([value (gen)] [count 0] [at at])
        (cond
          [(eof-object? value) count]
          [(>= at (vector-length vector)) count]
          [else
           (begin
             (vector-set! vector at value)
             (loop (gen) (+ count 1) (+ at 1)))])))
    (define generator->string
      (case-lambda
        [(gen) (list->string (generator->list gen))]
        [(gen n) (list->string (generator->list gen n))]))
    (define (generator-fold f seed . gs)
      (define (inner-fold seed)
        (let ([vs (map (lambda (g) (g)) gs)])
          (if (any eof-object? vs)
              seed
              (inner-fold (apply f (append vs (list seed)))))))
      (inner-fold seed))
    (define (generator-for-each f . gs)
      (let loop ()
        (let ([vs (map (lambda (g) (g)) gs)])
          (if (any eof-object? vs)
              (if #f #f)
              (begin (apply f vs) (loop))))))
    (define (generator-map->list f . gs)
      (let loop ([result '()])
        (let ([vs (map (lambda (g) (g)) gs)])
          (if (any eof-object? vs)
              (reverse result)
              (loop (cons (apply f vs) result))))))
    (define (generator-find pred g)
      (let loop ([v (g)])
        (if (or (pred v) (eof-object? v)) v (loop (g)))))
    (define (generator-count pred g)
      (generator-fold (lambda (v n) (if (pred v) (+ 1 n) n)) 0 g))
    (define (generator-any pred g)
      (let loop ([v (g)])
        (if (eof-object? v) #f (if (pred v) #t (loop (g))))))
    (define (generator-every pred g)
      (let loop ([v (g)])
        (if (eof-object? v) #t (if (pred v) (loop (g)) #f))))
    (define (generator-unfold g unfold . args)
      (apply unfold eof-object? (lambda (x) x) (lambda (x) (g))
        (g) args))
    (define (make-accumulator kons knil finalize)
      (let ([state knil])
        (lambda (obj)
          (if (eof-object? obj)
              (finalize state)
              (set! state (kons obj state))))))
    (define (count-accumulator)
      (make-accumulator
        (lambda (obj state) (+ 1 state))
        0
        (lambda (x) x)))
    (define (list-accumulator)
      (make-accumulator cons '() reverse))
    (define (reverse-list-accumulator)
      (make-accumulator cons '() (lambda (x) x)))
    (define (vector-accumulator)
      (make-accumulator
        cons
        '()
        (lambda (x) (list->vector (reverse x)))))
    (define (reverse-vector-accumulator)
      (make-accumulator cons '() list->vector))
    (define (vector-accumulator! vec at)
      (lambda (obj)
        (if (eof-object? obj)
            vec
            (begin (vector-set! vec at obj) (set! at (+ at 1))))))
    (define (bytevector-accumulator)
      (make-accumulator
        cons
        '()
        (lambda (x) (list->bytevector (reverse x)))))
    (define (bytevector-accumulator! bytevec at)
      (lambda (obj)
        (if (eof-object? obj)
            bytevec
            (begin
              (bytevector-u8-set! bytevec at obj)
              (set! at (+ at 1))))))
    (define (string-accumulator)
      (make-accumulator
        cons
        '()
        (lambda (lst) (list->string (reverse lst)))))
    (define (sum-accumulator)
      (make-accumulator + 0 (lambda (x) x)))
    (define (product-accumulator)
      (make-accumulator * 1 (lambda (x) x)))))
