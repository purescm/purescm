;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor/
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: %3a152/strings.sls
;;;;;; File header: %3a152/macros.scm
;;;; Definitions of macros
;;;;;; File header: %3a152/portable.scm
;;; SRFI 130 string library reference implementation		-*- Scheme -*-
;;; Olin Shivers 7/2000
;;; John Cowan 4/2016
;;;
;;; Copyright (c) 1988-1994 Massachusetts Institute of Technology.
;;; Copyright (c) 1998, 1999, 2000 Olin Shivers. 
;;; Copyright (c) 2016 John Cowan.
;;;   The details of the copyrights appear at the end of the file. Short
;;;   summary: BSD-style open source.
;;;;;; File header: %3a152/r7rs-shim.scm
;;;;;; File header: %3a152/extend-comparisons.scm
;;; Extend comparisons to 0 and 1 arguments.
;; 2017-10-04 Sudarshan S Chawathe <chaw@eip10.org>
(library (purs runtime srfi :152 strings)
  (export string? string-null? string-every string-any
   make-string string string-tabulate string-unfold
   string-unfold-right string->vector string->list
   vector->string list->string reverse-list->string
   string-length string-ref substring string-copy string-take
   string-take-right string-drop string-drop-right string-pad
   string-pad-right string-trim string-trim-right
   string-trim-both string-replace string=? string-ci=?
   string<? string-ci<? string>? string-ci>? string<=?
   string-ci<=? string>=? string-ci>=? string-prefix-length
   string-suffix-length string-prefix? string-suffix?
   string-index string-index-right string-skip
   string-skip-right string-contains string-contains-right
   string-take-while string-take-while-right string-drop-while
   string-drop-while-right string-break string-span
   string-append string-concatenate string-concatenate-reverse
   string-join string-fold string-fold-right string-map
   string-for-each string-count string-filter string-remove
   string-replicate string-segment string-split read-string
   write-string string-set! string-fill! string-copy!)
  (import
    (rename
      (except (rnrs) string->list string-for-each string-copy
        error)
      (string=? base-string=?) (string<? base-string<?)
      (string>? base-string>?) (string<=? base-string<=?)
      (string>=? base-string>=?) (string-ci=? base-string-ci=?)
      (string-ci<? base-string-ci<?)
      (string-ci>? base-string-ci>?)
      (string-ci<=? base-string-ci<=?)
      (string-ci>=? base-string-ci>=?))
    (except (rnrs mutable-strings) string-fill!) (rnrs r5rs)
    (purs runtime srfi :0) (purs runtime srfi :23) (purs runtime srfi private include))
  (begin
    (define-syntax receive
      (syntax-rules ()
        [(receive formals expression body ...)
         (call-with-values
           (lambda () expression)
           (lambda formals body ...))]))
    (define-syntax let-optionals*
      (syntax-rules ()
        [(let-optionals* arg (opt-clause ...) body ...)
         (let ([rest arg])
           (%let-optionals* rest (opt-clause ...) body ...))]))
    (define-syntax %let-optionals*
      (syntax-rules ()
        [(%let-optionals*
           arg
           (((var ...) xparser) opt-clause ...)
           body
           ...)
         (call-with-values
           (lambda () (xparser arg))
           (lambda (rest var ...)
             (%let-optionals* rest (opt-clause ...) body ...)))]
        [(%let-optionals*
           arg
           ((var default) opt-clause ...)
           body
           ...)
         (call-with-values
           (lambda ()
             (if (null? arg)
                 (values default '())
                 (values (car arg) (cdr arg))))
           (lambda (var rest)
             (%let-optionals* rest (opt-clause ...) body ...)))]
        [(%let-optionals*
           arg
           ((var default test) opt-clause ...)
           body
           ...)
         (call-with-values
           (lambda ()
             (if (null? arg)
                 (values default '())
                 (let ([var (car arg)])
                   (if test
                       (values var (cdr arg))
                       (error "arg failed LET-OPT test" var)))))
           (lambda (var rest)
             (%let-optionals* rest (opt-clause ...) body ...)))]
        [(%let-optionals*
           arg
           ((var default test supplied?) opt-clause ...)
           body
           ...)
         (call-with-values
           (lambda ()
             (if (null? arg)
                 (values default #f '())
                 (let ([var (car arg)])
                   (if test
                       (values var #t (cdr arg))
                       (error "arg failed LET-OPT test" var)))))
           (lambda (var supplied? rest)
             (%let-optionals* rest (opt-clause ...) body ...)))]
        [(%let-optionals* arg (rest) body ...)
         (let ([rest arg]) body ...)]
        [(%let-optionals* arg () body ...)
         (if (null? arg)
             (begin body ...)
             (error "Too many arguments in let-opt" arg))])))
  (begin
    (define check-arg
      (lambda (pred val proc)
        (if (pred val) val (error "Bad arg" val pred proc))))
    (define (add1 n) (+ 1 n))
    (define-syntax let-string-start+end
      (syntax-rules ()
        [(let-string-start+end (start end) proc s-exp args-exp body
           ...)
         (receive
           (start end)
           (string-parse-final-start+end proc s-exp args-exp)
           body
           ...)]
        [(let-string-start+end (start end rest) proc s-exp args-exp
           body ...)
         (receive
           (rest start end)
           (string-parse-start+end proc s-exp args-exp)
           body
           ...)]))
    (define-syntax let-string-start+end2
      (syntax-rules ()
        [(l-s-s+e2 (start1 end1 start2 end2) proc s1 s2 args body
           ...)
         (let ([procv proc])
           (let-string-start+end (start1 end1 rest) procv s1 args
             (let-string-start+end (start2 end2) procv s2 rest body
               ...)))]))
    (define (string-parse-start+end proc s args)
      (if (not (string? s)) (error "Non-string value" proc s))
      (let ([slen (string-length s)])
        (if (pair? args)
            (let ([start (car args)] [args (cdr args)])
              (if (and (integer? start) (exact? start) (>= start 0))
                  (receive
                    (end args)
                    (if (pair? args)
                        (let ([end (car args)] [args (cdr args)])
                          (if (and (integer? end)
                                   (exact? end)
                                   (<= end slen))
                              (values end args)
                              (error "Illegal substring END spec"
                                proc
                                end
                                s)))
                        (values slen args))
                    (if (<= start end)
                        (values args start end)
                        (error "Illegal substring START/END spec"
                          proc
                          start
                          end
                          s)))
                  (error "Illegal substring START spec" proc start s)))
            (values '() 0 slen))))
    (define (string-parse-final-start+end proc s args)
      (receive
        (rest start end)
        (string-parse-start+end proc s args)
        (if (pair? rest)
            (error "Extra arguments to procedure" proc rest)
            (values start end))))
    (define (substring-spec-ok? s start end)
      (and (string? s)
           (integer? start)
           (exact? start)
           (integer? end)
           (exact? end)
           (<= 0 start)
           (<= start end)
           (<= end (string-length s))))
    (define (check-substring-spec proc s start end)
      (if (not (substring-spec-ok? s start end))
          (error "Illegal substring spec." proc s start end)))
    (define (%substring s start end)
      (if (and (zero? start) (= end (string-length s)))
          s
          (substring s start end)))
    (define (string-fold kons knil s . maybe-start+end)
      (check-arg procedure? kons string-fold)
      (let-string-start+end (start end) string-fold s maybe-start+end
        (let lp ([v knil] [i start])
          (if (< i end) (lp (kons (string-ref s i) v) (+ i 1)) v))))
    (define (string-fold-right kons knil s . maybe-start+end)
      (check-arg procedure? kons string-fold-right)
      (let-string-start+end (start end) string-fold-right s maybe-start+end
        (let lp ([v knil] [i (- end 1)])
          (if (>= i start)
              (lp (kons (string-ref s i) v) (- i 1))
              v))))
    (define (string-unfold p f g seed . base+make-final)
      (check-arg procedure? p string-unfold)
      (check-arg procedure? f string-unfold)
      (check-arg procedure? g string-unfold)
      (let-optionals*
        base+make-final
        ((base "" (string? base))
          (make-final (lambda (x) "") (procedure? make-final)))
        (let lp ([chunks '()]
                 [nchars 0]
                 [chunk (make-string 40)]
                 [chunk-len 40]
                 [i 0]
                 [seed seed])
          (let lp2 ([i i] [seed seed])
            (if (not (p seed))
                (let ([c (f seed)] [seed (g seed)])
                  (if (< i chunk-len)
                      (begin (string-set! chunk i c) (lp2 (+ i 1) seed))
                      (let* ([nchars2 (+ chunk-len nchars)]
                             [chunk-len2 (min 4096 nchars2)]
                             [new-chunk (make-string chunk-len2)])
                        (string-set! new-chunk 0 c)
                        (lp (cons chunk chunks) (+ nchars chunk-len)
                            new-chunk chunk-len2 1 seed))))
                (let* ([final (make-final seed)]
                       [flen (string-length final)]
                       [base-len (string-length base)]
                       [j (+ base-len nchars i)]
                       [ans (make-string (+ j flen))])
                  (%string-copy! ans j final 0 flen)
                  (let ([j (- j i)])
                    (%string-copy! ans j chunk 0 i)
                    (let lp ([j j] [chunks chunks])
                      (if (pair? chunks)
                          (let* ([chunk (car chunks)]
                                 [chunks (cdr chunks)]
                                 [chunk-len (string-length chunk)]
                                 [j (- j chunk-len)])
                            (%string-copy! ans j chunk 0 chunk-len)
                            (lp j chunks)))))
                  (%string-copy! ans 0 base 0 base-len)
                  ans))))))
    (define (string-unfold-right p f g seed . base+make-final)
      (let-optionals*
        base+make-final
        ((base "" (string? base))
          (make-final (lambda (x) "") (procedure? make-final)))
        (let lp ([chunks '()]
                 [nchars 0]
                 [chunk (make-string 40)]
                 [chunk-len 40]
                 [i 40]
                 [seed seed])
          (let lp2 ([i i] [seed seed])
            (if (not (p seed))
                (let ([c (f seed)] [seed (g seed)])
                  (if (> i 0)
                      (let ([i (- i 1)])
                        (string-set! chunk i c)
                        (lp2 i seed))
                      (let* ([nchars2 (+ chunk-len nchars)]
                             [chunk-len2 (min 4096 nchars2)]
                             [new-chunk (make-string chunk-len2)]
                             [i (- chunk-len2 1)])
                        (string-set! new-chunk i c)
                        (lp (cons chunk chunks) (+ nchars chunk-len)
                            new-chunk chunk-len2 i seed))))
                (let* ([final (make-final seed)]
                       [flen (string-length final)]
                       [base-len (string-length base)]
                       [chunk-used (- chunk-len i)]
                       [j (+ base-len nchars chunk-used)]
                       [ans (make-string (+ j flen))])
                  (%string-copy! ans 0 final 0 flen)
                  (%string-copy! ans flen chunk i chunk-len)
                  (let lp ([j (+ flen chunk-used)] [chunks chunks])
                    (if (pair? chunks)
                        (let* ([chunk (car chunks)]
                               [chunks (cdr chunks)]
                               [chunk-len (string-length chunk)])
                          (%string-copy! ans j chunk 0 chunk-len)
                          (lp (+ j chunk-len) chunks))
                        (%string-copy! ans j base 0 base-len)))
                  ans))))))
    (define (string-every criterion s . maybe-start+end)
      (let-string-start+end (start end) string-every s maybe-start+end
        (or (= start end)
            (let lp ([i start])
              (let ([c (string-ref s i)] [i1 (+ i 1)])
                (if (= i1 end)
                    (criterion c)
                    (and (criterion c) (lp i1))))))))
    (define (string-any criterion s . maybe-start+end)
      (let-string-start+end (start end) string-any s maybe-start+end
        (and (< start end)
             (let lp ([i start])
               (let ([c (string-ref s i)] [i1 (+ i 1)])
                 (if (= i1 end)
                     (criterion c)
                     (or (criterion c) (lp i1))))))))
    (define (string-tabulate proc len)
      (check-arg procedure? proc string-tabulate)
      (check-arg
        (lambda (val) (and (integer? val) (exact? val) (<= 0 val)))
        len
        string-tabulate)
      (let ([s (make-string len)])
        (do ([i (- len 1) (- i 1)])
            ((< i 0))
          (string-set! s i (proc i)))
        s))
    (define (%string-prefix-length s1 start1 end1 s2 start2
             end2)
      (let* ([delta (min (- end1 start1) (- end2 start2))]
             [end1 (+ start1 delta)])
        (if (and (eq? s1 s2) (= start1 start2))
            delta
            (let lp ([i start1] [j start2])
              (if (or (>= i end1)
                      (not (char=? (string-ref s1 i) (string-ref s2 j))))
                  (- i start1)
                  (lp (+ i 1) (+ j 1)))))))
    (define (%string-suffix-length s1 start1 end1 s2 start2
             end2)
      (let* ([delta (min (- end1 start1) (- end2 start2))]
             [start1 (- end1 delta)])
        (if (and (eq? s1 s2) (= end1 end2))
            delta
            (let lp ([i (- end1 1)] [j (- end2 1)])
              (if (or (< i start1)
                      (not (char=? (string-ref s1 i) (string-ref s2 j))))
                  (- (- end1 i) 1)
                  (lp (- i 1) (- j 1)))))))
    (define (string-prefix-length s1 s2 . maybe-starts+ends)
      (let-string-start+end2 (start1 end1 start2 end2) string-prefix-length s1 s2
        maybe-starts+ends
        (%string-prefix-length s1 start1 end1 s2 start2 end2)))
    (define (string-suffix-length s1 s2 . maybe-starts+ends)
      (let-string-start+end2 (start1 end1 start2 end2) string-suffix-length s1 s2
        maybe-starts+ends
        (%string-suffix-length s1 start1 end1 s2 start2 end2)))
    (define (string-prefix? s1 s2 . maybe-starts+ends)
      (let-string-start+end2 (start1 end1 start2 end2) string-prefix? s1 s2
        maybe-starts+ends
        (%string-prefix? s1 start1 end1 s2 start2 end2)))
    (define (string-suffix? s1 s2 . maybe-starts+ends)
      (let-string-start+end2 (start1 end1 start2 end2) string-suffix? s1 s2
        maybe-starts+ends
        (%string-suffix? s1 start1 end1 s2 start2 end2)))
    (define (%string-prefix? s1 start1 end1 s2 start2 end2)
      (let ([len1 (- end1 start1)])
        (and (<= len1 (- end2 start2))
             (= (%string-prefix-length s1 start1 end1 s2 start2 end2)
                len1))))
    (define (%string-suffix? s1 start1 end1 s2 start2 end2)
      (let ([len1 (- end1 start1)])
        (and (<= len1 (- end2 start2))
             (= len1
                (%string-suffix-length s1 start1 end1 s2 start2 end2)))))
    (define (string-take s n)
      (check-arg string? s string-take)
      (check-arg
        (lambda (val)
          (and (integer? n) (exact? n) (<= 0 n (string-length s))))
        n
        string-take)
      (%substring s 0 n))
    (define (string-take-right s n)
      (check-arg string? s string-take-right)
      (let ([len (string-length s)])
        (check-arg
          (lambda (val) (and (integer? n) (exact? n) (<= 0 n len)))
          n
          string-take-right)
        (%substring s (- len n) len)))
    (define (string-drop s n)
      (check-arg string? s string-drop)
      (let ([len (string-length s)])
        (check-arg
          (lambda (val) (and (integer? n) (exact? n) (<= 0 n len)))
          n
          string-drop)
        (%substring s n len)))
    (define (string-drop-right s n)
      (check-arg string? s string-drop-right)
      (let ([len (string-length s)])
        (check-arg
          (lambda (val) (and (integer? n) (exact? n) (<= 0 n len)))
          n
          string-drop-right)
        (%substring s 0 (- len n))))
    (define (string-trim s . criterion+start+end)
      (let-optionals*
        criterion+start+end
        ((criterion char-whitespace?) rest)
        (let-string-start+end (start end) string-trim s rest
          (cond
            [(string-skip s criterion start end) =>
             (lambda (i) (%substring s i end))]
            [else ""]))))
    (define (string-trim-right s . criterion+start+end)
      (let-optionals*
        criterion+start+end
        ((criterion char-whitespace?) rest)
        (let-string-start+end (start end) string-trim-right s rest
          (cond
            [(string-skip-right s criterion start end) =>
             (lambda (i) (%substring s start (+ 1 i)))]
            [else ""]))))
    (define (string-trim-both s . criterion+start+end)
      (let-optionals*
        criterion+start+end
        ((criterion char-whitespace?) rest)
        (let-string-start+end (start end) string-trim-both s rest
          (cond
            [(string-skip s criterion start end) =>
             (lambda (i)
               (%substring
                 s
                 i
                 (+ 1 (string-skip-right s criterion i end))))]
            [else ""]))))
    (define (string-pad-right s n . char+start+end)
      (let-optionals*
        char+start+end
        ((char #\space (char? char)) rest)
        (let-string-start+end (start end) string-pad-right s rest
          (check-arg
            (lambda (n) (and (integer? n) (exact? n) (<= 0 n)))
            n
            string-pad-right)
          (let ([len (- end start)])
            (if (<= n len)
                (%substring s start (+ start n))
                (let ([ans (make-string n char)])
                  (%string-copy! ans 0 s start end)
                  ans))))))
    (define (string-pad s n . char+start+end)
      (let-optionals*
        char+start+end
        ((char #\space (char? char)) rest)
        (let-string-start+end (start end) string-pad s rest
          (check-arg
            (lambda (n) (and (integer? n) (exact? n) (<= 0 n)))
            n
            string-pad)
          (let ([len (- end start)])
            (if (<= n len)
                (%substring s (- end n) end)
                (let ([ans (make-string n char)])
                  (%string-copy! ans (- n len) s start end)
                  ans))))))
    (define (string-remove criterion s . maybe-start+end)
      (let-string-start+end (start end) string-remove s maybe-start+end
        (let* ([slen (- end start)]
               [temp (make-string slen)]
               [ans-len (string-fold
                          (lambda (c i)
                            (if (criterion c)
                                i
                                (begin (string-set! temp i c) (+ i 1))))
                          0 s start end)])
          (if (= ans-len slen) temp (substring temp 0 ans-len)))))
    (define (string-filter criterion s . maybe-start+end)
      (let-string-start+end (start end) string-filter s maybe-start+end
        (let* ([slen (- end start)]
               [temp (make-string slen)]
               [ans-len (string-fold
                          (lambda (c i)
                            (if (criterion c)
                                (begin (string-set! temp i c) (+ i 1))
                                i))
                          0 s start end)])
          (if (= ans-len slen) temp (substring temp 0 ans-len)))))
    (define (string-index str criterion . maybe-start+end)
      (let-string-start+end (start end) string-index str maybe-start+end
        (let lp ([i start])
          (and (< i end)
               (if (criterion (string-ref str i)) i (lp (+ i 1)))))))
    (define (string-index-right str criterion . maybe-start+end)
      (let-string-start+end (start end) string-index-right str maybe-start+end
        (let lp ([i (- end 1)])
          (and (>= i start)
               (if (criterion (string-ref str i)) i (lp (- i 1)))))))
    (define (string-skip str criterion . maybe-start+end)
      (let-string-start+end (start end) string-skip str maybe-start+end
        (let lp ([i start])
          (and (< i end)
               (if (criterion (string-ref str i)) (lp (+ i 1)) i)))))
    (define (string-skip-right str criterion . maybe-start+end)
      (let-string-start+end (start end) string-skip-right str maybe-start+end
        (let lp ([i (- end 1)])
          (and (>= i start)
               (if (criterion (string-ref str i)) (lp (- i 1)) i)))))
    (define (string-take-while s criterion . maybe-start+end)
      (let-string-start+end (start end) string-take-while s maybe-start+end
        (let ([idx (string-skip s criterion start end)])
          (if idx (%substring s 0 idx) ""))))
    (define (string-take-while-right s criterion .
             maybe-start+end)
      (let-string-start+end (start end) string-take-while s maybe-start+end
        (let ([idx (string-skip-right s criterion start end)])
          (if idx (%substring s (+ idx 1) (string-length s)) ""))))
    (define (string-drop-while s criterion . maybe-start+end)
      (let-string-start+end (start end) string-drop-while s maybe-start+end
        (let ([idx (string-skip s criterion start end)])
          (if idx (%substring s idx (string-length s)) s))))
    (define (string-drop-while-right s criterion .
             maybe-start+end)
      (let-string-start+end (start end) string-drop-while s maybe-start+end
        (let ([idx (string-skip-right s criterion start end)])
          (if idx (%substring s 0 (+ idx 1)) s))))
    (define (string-span s criterion . maybe-start+end)
      (let-string-start+end (start end) string-span s maybe-start+end
        (let ([idx (string-skip s criterion start end)])
          (if idx
              (values
                (%substring s 0 idx)
                (%substring s idx (string-length s)))
              (values "" s)))))
    (define (string-break s criterion . maybe-start+end)
      (let-string-start+end (start end) string-break s maybe-start+end
        (let ([idx (string-index s criterion start end)])
          (if idx
              (values
                (%substring s 0 idx)
                (%substring s idx (string-length s)))
              (values s "")))))
    (define (string-count s criterion . maybe-start+end)
      (let-string-start+end (start end) string-count s maybe-start+end
        (do ([i start (+ i 1)]
             [count 0 (if (criterion (string-ref s i))
                          (+ count 1)
                          count)])
            ((>= i end) count))))
    (define (%string-copy! to tstart from fstart fend)
      (if (> fstart tstart)
          (do ([i fstart (+ i 1)] [j tstart (+ j 1)])
              ((>= i fend))
            (string-set! to j (string-ref from i)))
          (do ([i (- fend 1) (- i 1)]
               [j (+ -1 tstart (- fend fstart)) (- j 1)])
              ((< i fstart))
            (string-set! to j (string-ref from i)))))
    (define (string-contains text pattern . maybe-starts+ends)
      (let-string-start+end2 (t-start t-end p-start p-end) string-contains text pattern
        maybe-starts+ends
        (%kmp-search pattern text char=? p-start p-end t-start
          t-end)))
    (define (string-contains-right text pattern .
             maybe-starts+ends)
      (let-string-start+end2 (t-start t-end p-start p-end) string-contains-right text
        pattern maybe-starts+ends
        (let* ([t-len (string-length text)]
               [p-len (string-length pattern)]
               [p-size (- p-end p-start)]
               [rt-start (- t-len t-end)]
               [rt-end (- t-len t-start)]
               [rp-start (- p-len p-end)]
               [rp-end (- p-len p-start)]
               [res (%kmp-search (string-reverse pattern)
                      (string-reverse text) char=? rp-start rp-end rt-start
                      rt-end)])
          (if res (- t-len res p-size) #f))))
    (define (%kmp-search pattern text c= p-start p-end t-start
             t-end)
      (let ([plen (- p-end p-start)]
            [rv (make-kmp-restart-vector pattern c= p-start p-end)])
        (let lp ([ti t-start]
                 [pi 0]
                 [tj (- t-end t-start)]
                 [pj plen])
          (if (= pi plen)
              (- ti plen)
              (and (<= pj tj)
                   (if (c= (string-ref text ti)
                           (string-ref pattern (+ p-start pi)))
                       (lp (+ 1 ti) (+ 1 pi) (- tj 1) (- pj 1))
                       (let ([pi (vector-ref rv pi)])
                         (if (= pi -1)
                             (lp (+ ti 1) 0 (- tj 1) plen)
                             (lp ti pi tj (- plen pi))))))))))
    (define (make-kmp-restart-vector pattern .
             maybe-c=+start+end)
      (let-optionals*
        maybe-c=+start+end
        ((c= char=?) rest)
        (receive
          (rest2 start end)
          (string-parse-start+end
            make-kmp-restart-vector
            pattern
            rest)
          (let* ([rvlen (- end start)] [rv (make-vector rvlen -1)])
            (if (> rvlen 0)
                (let ([rvlen-1 (- rvlen 1)]
                      [c0 (string-ref pattern start)])
                  (let lp1 ([i 0] [j -1] [k start])
                    (if (< i rvlen-1)
                        (let lp2 ([j j])
                          (cond
                            [(= j -1)
                             (let ([i1 (+ i 1)]
                                   [ck+1 (string-ref pattern (add1 k))])
                               (vector-set! rv i1 (if (c= ck+1 c0) -1 0))
                               (lp1 i1 0 (+ k 1)))]
                            [(c= (string-ref pattern k)
                                 (string-ref pattern (+ j start)))
                             (let* ([i1 (+ 1 i)] [j1 (+ 1 j)])
                               (vector-set! rv i1 j1)
                               (lp1 i1 j1 (+ k 1)))]
                            [else (lp2 (vector-ref rv j))]))))))
            rv))))
    (define (kmp-step pat rv c i c= p-start)
      (let lp ([i i])
        (if (c= c (string-ref pat (+ i p-start)))
            (+ i 1)
            (let ([i (vector-ref rv i)]) (if (= i -1) 0 (lp i))))))
    (define (string-kmp-partial-search pat rv s i .
             c=+p-start+s-start+s-end)
      (let-optionals*
        c=+p-start+s-start+s-end
        ((c= char=?) (p-start 0) rest)
        (receive
          (rest2 s-start s-end)
          (string-parse-start+end string-kmp-partial-search s rest)
          (let ([patlen (vector-length rv)])
            (let lp ([si s-start] [vi i])
              (cond
                [(= vi patlen) (- si)]
                [(= si s-end) vi]
                [else
                 (let ([c (string-ref s si)])
                   (lp (+ si 1)
                       (let lp2 ([vi vi])
                         (if (c= c (string-ref pat (+ vi p-start)))
                             (+ vi 1)
                             (let ([vi (vector-ref rv vi)])
                               (if (= vi -1) 0 (lp2 vi)))))))]))))))
    (define (string-null? s) (zero? (string-length s)))
    (define (string-reverse s . maybe-start+end)
      (let-string-start+end (start end) string-reverse s maybe-start+end
        (let* ([len (- end start)] [ans (make-string len)])
          (do ([i start (+ i 1)] [j (- len 1) (- j 1)])
              ((< j 0))
            (string-set! ans j (string-ref s i)))
          ans)))
    (define (reverse-list->string clist)
      (let* ([len (length clist)] [s (make-string len)])
        (do ([i (- len 1) (- i 1)] [clist clist (cdr clist)])
            ((not (pair? clist)))
          (string-set! s i (car clist)))
        s))
    (define (string-concatenate strings)
      (let* ([total (do ([strings strings (cdr strings)]
                         [i 0 (+ i (string-length (car strings)))])
                        ((not (pair? strings)) i))]
             [ans (make-string total)])
        (let lp ([i 0] [strings strings])
          (if (pair? strings)
              (let* ([s (car strings)] [slen (string-length s)])
                (%string-copy! ans i s 0 slen)
                (lp (+ i slen) (cdr strings)))))
        ans))
    (define (string-concatenate-reverse string-list .
             maybe-final+end)
      (let-optionals*
        maybe-final+end
        ((final "" (string? final))
          (end (string-length final)
               (and (integer? end)
                    (exact? end)
                    (<= 0 end (string-length final)))))
        (let ([len (let lp ([sum 0] [lis string-list])
                     (if (pair? lis)
                         (lp (+ sum (string-length (car lis))) (cdr lis))
                         sum))])
          (%finish-string-concatenate-reverse
            len
            string-list
            final
            end))))
    (define (%finish-string-concatenate-reverse len string-list
             final end)
      (let ([ans (make-string (+ end len))])
        (%string-copy! ans len final 0 end)
        (let lp ([i len] [lis string-list])
          (if (pair? lis)
              (let* ([s (car lis)]
                     [lis (cdr lis)]
                     [slen (string-length s)]
                     [i (- i slen)])
                (%string-copy! ans i s 0 slen)
                (lp i lis))))
        ans))
    (define (string-replace s1 s2 start1 end1 . maybe-start+end)
      (check-substring-spec string-replace s1 start1 end1)
      (let-string-start+end (start2 end2) string-replace s2 maybe-start+end
        (let* ([slen1 (string-length s1)]
               [sublen2 (- end2 start2)]
               [alen (+ (- slen1 (- end1 start1)) sublen2)]
               [ans (make-string alen)])
          (%string-copy! ans 0 s1 0 start1)
          (%string-copy! ans start1 s2 start2 end2)
          (%string-copy! ans (+ start1 sublen2) s1 end1 slen1)
          ans)))
    (define (string-split s delimiter . args)
      (if (not (string? s)) (error "string expected" s))
      (if (not (string? delimiter))
          (error "string expected" delimiter))
      (let ([slen (string-length s)])
        (receive (grammar limit no-limit start end)
          (if (pair? args)
              (if (pair? (cdr args))
                  (if (pair? (cddr args))
                      (if (pair? (cdddr args))
                          (values (car args) (cadr args) #f (caddr args)
                            (cadddr args))
                          (values (car args) (cadr args) #f (caddr args)
                            slen))
                      (values (car args) (cadr args) #f 0 slen))
                  (values (car args) #f #t 0 slen))
              (values 'infix #f #t 0 slen))
          (if (not (memq grammar '(infix strict-infix prefix suffix)))
              (error "grammar must be one of (infix strict-infix prefix suffix)"
                grammar))
          (if (not limit) (set! no-limit #t))
          (if (not (or no-limit
                       (and (integer? limit) (exact? limit) (>= limit 0))))
              (error "limit must be exact nonnegative integer or #f"
                limit))
          (if (not (and (integer? start) (exact? start)))
              (error "start argument must be exact integer" start))
          (if (not (<= 0 start slen))
              (error "start argument out of range" start))
          (if (not (<= 0 end slen))
              (error "end argument out of range" end))
          (if (not (<= start end))
              (error "start argument is greater than end argument"
                (list start end)))
          (cond
            [(= start end)
             (if (eq? grammar 'strict-infix)
                 (error "empty string cannot be spilt with strict-infix grammar")
                 '())]
            [(string-null? delimiter)
             (%string-split-chars s start end limit)]
            [else
             (%string-split s start end delimiter grammar limit)]))))
    (define (%string-split-chars s start end limit)
      (if (not limit)
          (map string (string->list s start end))
          (let loop ([r '()] [c start] [n 0])
            (cond
              [(= c end) (reverse r)]
              [(>= n limit) (reverse (cons (substring s c end) r))]
              [else
               (loop
                 (cons (string (string-ref s c)) r)
                 (+ c 1)
                 (+ n 1))]))))
    (define (%string-split s start end delimiter grammar limit)
      (let ([dlen (string-length delimiter)])
        (define (finish r c)
          (let ([rest (substring s c end)])
            (if (and (eq? grammar 'suffix) (string-null? rest))
                (reverse r)
                (reverse (cons rest r)))))
        (define (scan r c n)
          (if (and limit (>= n limit))
              (finish r c)
              (let ([i (string-contains s delimiter c end)])
                (if i
                    (let ([fragment (substring s c i)])
                      (if (and (= n 0)
                               (eq? grammar 'prefix)
                               (string-null? fragment))
                          (scan r (+ i dlen) (+ n 1))
                          (scan (cons fragment r) (+ i dlen) (+ n 1))))
                    (finish r c)))))
        (scan '() start 0)))
    (define (string-replicate s from . maybe-to+start+end)
      (check-arg
        (lambda (val) (and (integer? val) (exact? val)))
        from
        string-replicate)
      (receive
        (to start end)
        (if (pair? maybe-to+start+end)
            (let-string-start+end (start end) string-replicate s (cdr maybe-to+start+end)
              (let ([to (car maybe-to+start+end)])
                (check-arg
                  (lambda (val)
                    (and (integer? val) (exact? val) (<= from val)))
                  to
                  string-replicate)
                (values to start end)))
            (let ([slen (string-length
                          (check-arg string? s string-replicate))])
              (values (+ from slen) 0 slen)))
        (let ([slen (- end start)] [anslen (- to from)])
          (cond
            [(zero? anslen) ""]
            [(zero? slen)
             (error "Cannot replicate empty (sub)string"
               string-replicate
               s
               from
               to
               start
               end)]
            [(= 1 slen) (make-string anslen (string-ref s start))]
            [(= (floor (/ from slen)) (floor (/ to slen)))
             (substring
               s
               (+ start (modulo from slen))
               (+ start (modulo to slen)))]
            [else
             (let ([ans (make-string anslen)])
               (%multispan-repcopy! ans 0 s from to start end)
               ans)]))))
    (define (%multispan-repcopy! target tstart s sfrom sto start
             end)
      (let* ([slen (- end start)]
             [i0 (+ start (modulo sfrom slen))]
             [total-chars (- sto sfrom)])
        (%string-copy! target tstart s i0 end)
        (let* ([ncopied (- end i0)]
               [nleft (- total-chars ncopied)]
               [nspans (quotient nleft slen)])
          (do ([i (+ tstart ncopied) (+ i slen)]
               [nspans nspans (- nspans 1)])
              ((zero? nspans)
               (%string-copy! target i s start
                 (+ start (- total-chars (- i tstart)))))
            (%string-copy! target i s start end)))))
    (define (string-join strings . delim+grammar)
      (let-optionals*
        delim+grammar
        ((delim " " (string? delim)) (grammar 'infix))
        (let ([buildit (lambda (lis final)
                         (let recur ([lis lis])
                           (if (pair? lis)
                               (cons
                                 delim
                                 (cons (car lis) (recur (cdr lis))))
                               final)))])
          (cond
            [(pair? strings)
             (string-concatenate
               (case grammar
                 [(infix strict-infix)
                  (cons (car strings) (buildit (cdr strings) '()))]
                 [(prefix) (buildit strings '())]
                 [(suffix)
                  (cons
                    (car strings)
                    (buildit (cdr strings) (list delim)))]
                 [else
                  (error "Illegal join grammar" grammar string-join)]))]
            [(not (null? strings))
             (error "STRINGS parameter not list." strings string-join)]
            [(eq? grammar 'strict-infix)
             (error "Empty list cannot be joined with STRICT-INFIX grammar."
               string-join)]
            [else ""]))))
    (define (string-segment str k)
      (if (< k 1) (error "minimum segment size is 1" k))
      (let ([len (string-length str)])
        (let loop ([start 0] [result '()])
          (if (= start len)
              (reverse result)
              (let ([end (min (+ start k) len)])
                (loop end (cons (%substring str start end) result))))))))
  (begin
    (define (string-fill! s char . maybe-start+end)
      (check-arg char? char string-fill!)
      (let-string-start+end (start end) string-fill! s maybe-start+end
        (do ([i (- end 1) (- i 1)])
            ((< i start))
          (string-set! s i char))))
    (define (string-copy! to tstart from . maybe-fstart+fend)
      (let-string-start+end (fstart fend) string-copy! from maybe-fstart+fend
        (check-arg integer? tstart string-copy!)
        (check-substring-spec
          string-copy!
          to
          tstart
          (+ tstart (- fend fstart)))
        (%string-copy! to tstart from fstart fend)))
    (define (string->list s . maybe-start+end)
      (let-string-start+end (start end) string->list s maybe-start+end
        (do ([i (- end 1) (- i 1)]
             [ans '() (cons (string-ref s i) ans)])
            ((< i start) ans))))
    (define (string->vector s . maybe-start+end)
      (let-string-start+end (start end) string->vector s maybe-start+end
        (let ([vector (make-vector (- end start))])
          (do ([i (- end 1) (- i 1)])
              ((< i start) vector)
            (vector-set! vector (- i start) (string-ref s i))))))
    (define (vector->string vector . maybe-start+end)
      (let ([start 0] [end (vector-length vector)])
        (case (length maybe-start+end)
          [(1) (set! start (car maybe-start+end))]
          [(2) (set! end (cadr maybe-start+end))])
        (let ([s (make-string (- end start))])
          (do ([i (- end 1) (- i 1)])
              ((< i start) s)
            (string-set! s (- i start) (vector-ref vector i))))))
    (define (string-map f x . rest)
      (define (string-map1 f x)
        (list->string (map f (string->list x))))
      (define (string-map2 f x y)
        (list->string (map f (string->list x) (string->list y))))
      (define (string-mapn f lists)
        (list->string (apply map f (map string->list lists))))
      (case (length rest)
        [(0) (string-map1 f x)]
        [(1) (string-map2 f x (car rest))]
        [else (string-mapn f (cons x rest))]))
    (define (string-for-each f s . rest)
      (define (for-each1 i n)
        (if (< i n)
            (begin (f (string-ref s i)) (for-each1 (+ i 1) n))
            (if #f #f)))
      (define (for-each2 s2 i n)
        (if (< i n)
            (begin
              (f (string-ref s i) (string-ref s2 i))
              (for-each2 s2 (+ i 1) n))
            (if #f #f)))
      (define (for-each-n revstrings i n)
        (if (< i n)
            (do ([rev revstrings (cdr rev)]
                 [chars '() (cons (string-ref (car rev) i) chars)])
                ((null? rev)
                 (apply f chars)
                 (for-each-n revstrings (+ i 1) n)))
            (if #f #f)))
      (let ([n (string-length s)])
        (cond
          [(null? rest) (for-each1 0 n)]
          [(and (null? (cdr rest))
                (string? (car rest))
                (= n (string-length (car rest))))
           (for-each2 (car rest) 0 n)]
          [else
           (let ([args (cons s rest)])
             (do ([ss rest (cdr ss)])
                 ((null? ss) (for-each-n (reverse args) 0 n))
               (let ([x (car ss)])
                 (if (or (not (string? x)) (not (= n (string-length x))))
                     (error "illegal-arguments" (cons f args))))))])))
    (define (string-copy s . maybe-start+end)
      (let-string-start+end (start end) string-copy! s
        maybe-start+end (%substring s start end)))
    (cond-expand
      (chicken)
      (else
        (define read-string
          (case-lambda
            [(k) (read-string k (current-input-port))]
            [(k port)
             (let loop ([i 0] [o '()])
               (if (>= i k)
                   (list->string (reverse o))
                   (let ([c (read-char port)])
                     (if (eof-object? c)
                         (if (= i 0) c (list->string (reverse o)))
                         (loop (+ i 1) (cons c o))))))]))))
    (define write-string
      (case-lambda
        [(str) (display str)]
        [(str port) (display str port)]
        [(str port start)
         (write-string str port start (string-length str))]
        [(str port start end)
         (display (%substring str start end) port)])))
  (begin
    (define-syntax define-comparison/base/pairs
      (syntax-rules ()
        [(_ (name . base-name) ...)
         (begin
           (define (name . strs)
             (or (null? strs) (null? (cdr strs)) (apply base-name strs)))
           ...)]))
    (define-comparison/base/pairs (string=? . base-string=?) (string<? . base-string<?)
      (string>? . base-string>?) (string<=? . base-string<=?)
      (string>=? . base-string>=?)
      (string-ci=? . base-string-ci=?)
      (string-ci<? . base-string-ci<?)
      (string-ci>? . base-string-ci>?)
      (string-ci<=? . base-string-ci<=?)
      (string-ci>=? . base-string-ci>=?))))
