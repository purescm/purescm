;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: %3a171/transducers.sls
#!r6rs
(library (srfi :171 transducers)
  (export rcons reverse-rcons rcount rany revery list-transduce
   vector-transduce string-transduce bytevector-u8-transduce
   port-transduce compose tmap tfilter tremove treplace
   tfilter-map tdrop tdrop-while ttake ttake-while tconcatenate
   tappend-map tdelete-neighbor-dupes tdelete-duplicates
   tflatten tsegment tpartition tinterpose tlog tenumerate)
  (import
    (except (rnrs) assoc filter find fold-right map partition remove
      for-each member define-record-type list->vector
      vector-for-each vector-map vector-fill! vector->list error
      string-hash string-ci-hash)
    (srfi :1 lists) (srfi :9 records) (srfi :23 error)
    (srfi :43 vectors) (srfi :69 basic-hash-tables)
    (srfi :171 meta))
  (define-record-type <nothing> (make-nothing) nothing?)
  (define nothing (make-nothing))
  (define rcons
    (case-lambda
      [() '()]
      [(lst) (reverse! lst)]
      [(lst x) (cons x lst)]))
  (define reverse-rcons
    (case-lambda [() '()] [(lst) lst] [(lst x) (cons x lst)]))
  (define rcount
    (case-lambda
      [() 0]
      [(result) result]
      [(result input) (+ 1 result)]))
  (define (rany pred)
    (case-lambda
      [() #f]
      [(result) result]
      [(result input) (if (pred input) (reduced input) #f)]))
  (define (revery pred)
    (case-lambda
      [() #t]
      [(result) result]
      [(result input)
       (if (and result (pred input)) input (reduced #f))]))
  (define list-transduce
    (case-lambda
      [(xform f coll) (list-transduce xform f (f) coll)]
      [(xform f init coll)
       (let* ([xf (xform f)] [result (list-reduce xf init coll)])
         (xf result))]))
  (define vector-transduce
    (case-lambda
      [(xform f coll) (vector-transduce xform f (f) coll)]
      [(xform f init coll)
       (let* ([xf (xform f)] [result (vector-reduce xf init coll)])
         (xf result))]))
  (define string-transduce
    (case-lambda
      [(xform f coll) (string-transduce xform f (f) coll)]
      [(xform f init coll)
       (let* ([xf (xform f)] [result (string-reduce xf init coll)])
         (xf result))]))
  (define bytevector-u8-transduce
    (case-lambda
      [(xform f coll) (bytevector-u8-transduce xform f (f) coll)]
      [(xform f init coll)
       (let* ([xf (xform f)]
              [result (bytevector-u8-reduce xf init coll)])
         (xf result))]))
  (define port-transduce
    (case-lambda
      [(xform f by port) (port-transduce xform f (f) by port)]
      [(xform f init by port)
       (let* ([xf (xform f)]
              [result (port-reduce xf init by port)])
         (xf result))]))
  (define compose
    (case-lambda
      [() (lambda (x) x)]
      [(f) f]
      [(f g) (lambda (x) (f (g x)))]
      [(f . gs) (reduce compose f gs)]))
  (define (tmap f)
    (lambda (reducer)
      (case-lambda
        [() (reducer)]
        [(result) (reducer result)]
        [(result input) (reducer result (f input))])))
  (define (tfilter pred)
    (lambda (reducer)
      (case-lambda
        [() (reducer)]
        [(result) (reducer result)]
        [(result input)
         (if (pred input) (reducer result input) result)])))
  (define (tremove pred)
    (lambda (reducer)
      (case-lambda
        [() (reducer)]
        [(result) (reducer result)]
        [(result input)
         (if (not (pred input)) (reducer result input) result)])))
  (define (tfilter-map f) (compose (tmap f) (tfilter values)))
  (define (make-replacer map)
    (cond
      [(list? map)
       (lambda (x)
         (let ([replacer? (assoc x map)])
           (if replacer? (cdr replacer?) x)))]
      [(hash-table? map)
       (lambda (x) (hash-table-ref/default map x x))]))
  (define (treplace map) (tmap (make-replacer map)))
  (define (tdrop n)
    (lambda (reducer)
      (let ([new-n (+ 1 n)])
        (case-lambda
          [() (reducer)]
          [(result) (reducer result)]
          [(result input)
           (set! new-n (- new-n 1))
           (if (positive? new-n) result (reducer result input))]))))
  (define (tdrop-while pred)
    (lambda (reducer)
      (let ([drop? #t])
        (case-lambda
          [() (reducer)]
          [(result) (reducer result)]
          [(result input)
           (if (and (pred input) drop?)
               result
               (begin (set! drop? #f) (reducer result input)))]))))
  (define (ttake n)
    (lambda (reducer)
      (let ([new-n n])
        (case-lambda
          [() (reducer)]
          [(result) (reducer result)]
          [(result input)
           (let ([result (if (positive? new-n)
                             (reducer result input)
                             result)])
             (set! new-n (- new-n 1))
             (if (not (positive? new-n))
                 (ensure-reduced result)
                 result))]))))
  (define ttake-while
    (case-lambda
      [(pred) (ttake-while pred (lambda (result input) result))]
      [(pred retf)
       (lambda (reducer)
         (let ([take? #t])
           (case-lambda
             [() (reducer)]
             [(result) (reducer result)]
             [(result input)
              (if (and take? (pred input))
                  (reducer result input)
                  (begin
                    (set! take? #f)
                    (ensure-reduced (retf result input))))])))]))
  (define (tconcatenate reducer)
    (let ([preserving-reducer (preserving-reduced reducer)])
      (case-lambda
        [() (reducer)]
        [(result) (reducer result)]
        [(result input)
         (list-reduce preserving-reducer result input)])))
  (define (tappend-map f) (compose (tmap f) tconcatenate))
  (define tflatten
    (lambda (reducer)
      (case-lambda
        [() '()]
        [(result) (reducer result)]
        [(result input)
         (if (list? input)
             (list-reduce
               (preserving-reduced (tflatten reducer))
               result
               input)
             (reducer result input))])))
  (define tdelete-neighbor-dupes
    (case-lambda
      [() (tdelete-neighbor-dupes equal?)]
      [(equality-pred?)
       (lambda (reducer)
         (let ([prev nothing])
           (case-lambda
             [() (reducer)]
             [(result) (reducer result)]
             [(result input)
              (if (equality-pred? prev input)
                  result
                  (begin (set! prev input) (reducer result input)))])))]))
  (define tdelete-duplicates
    (case-lambda
      [() (tdelete-duplicates equal?)]
      [(equality-pred?)
       (lambda (reducer)
         (let ([already-seen (make-hash-table equality-pred?)])
           (case-lambda
             [() (reducer)]
             [(result) (reducer result)]
             [(result input)
              (if (hash-table-exists? already-seen input)
                  result
                  (begin
                    (hash-table-set! already-seen input #t)
                    (reducer result input)))])))]))
  (define (tsegment n)
    (if (not (and (integer? n) (positive? n)))
        (error "argument to tsegment must be a positive integer")
        (lambda (reducer)
          (let ([i 0] [collect (make-vector n)])
            (case-lambda
              [() (reducer)]
              [(result)
               (let ([result (if (zero? i)
                                 result
                                 (reducer
                                   result
                                   (vector->list collect 0 i)))])
                 (set! i 0)
                 (reducer result))]
              [(result input)
               (vector-set! collect i input)
               (set! i (+ i 1))
               (if (< i n)
                   result
                   (let ([next-input (vector->list collect 0 i)])
                     (set! i 0)
                     (reducer result next-input)))])))))
  (define (tpartition f)
    (lambda (reducer)
      (let* ([prev nothing] [collect '()])
        (case-lambda
          [() (reducer)]
          [(result)
           (let ([result (if (null? collect)
                             result
                             (reducer result (reverse! collect)))])
             (set! collect '())
             (reducer result))]
          [(result input)
           (let ([fout (f input)])
             (cond
               [(or (equal? fout prev) (nothing? prev))
                (set! prev fout)
                (set! collect (cons input collect))
                result]
               [else
                (let ([next-input (reverse! collect)])
                  (set! prev fout)
                  (set! collect (list input))
                  (reducer result next-input))]))]))))
  (define (tinterpose elem)
    (lambda (reducer)
      (let ([send-elem? #f])
        (case-lambda
          [() (reducer)]
          [(result) (reducer result)]
          [(result input)
           (if send-elem?
               (let ([result (reducer result elem)])
                 (if (reduced? result) result (reducer result input)))
               (begin (set! send-elem? #t) (reducer result input)))]))))
  (define tenumerate
    (case-lambda
      [() (tenumerate 0)]
      [(n)
       (lambda (reducer)
         (let ([n n])
           (case-lambda
             [() (reducer)]
             [(result) (reducer result)]
             [(result input)
              (let ([input (cons n input)])
                (set! n (+ n 1))
                (reducer result input))])))]))
  (define tlog
    (case-lambda
      [() (tlog (lambda (result input) (write input) (newline)))]
      [(log-function)
       (lambda (reducer)
         (case-lambda
           [() (reducer)]
           [(result) (reducer result)]
           [(result input)
            (log-function result input)
            (reducer result input)]))])))
