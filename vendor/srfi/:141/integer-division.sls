;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: %3a141/integer-division.sls
;;;;;; File header: %3a141/srfi-141-impl.scm
(library (srfi :141 integer-division)
  (export ceiling/ ceiling-quotient ceiling-remainder floor/
    floor-quotient floor-remainder truncate/ truncate-quotient
    truncate-remainder round/ round-quotient round-remainder
    euclidean/ euclidean-quotient euclidean-remainder balanced/
    balanced-quotient balanced-remainder)
  (import (rnrs) (rnrs r5rs) (srfi private include))
  (begin
    (define-syntax receive
      (syntax-rules ()
        [(receive formals expression body ...)
         (call-with-values
           (lambda () expression)
           (lambda formals body ...))]))
    (define (exact-integer? x) (and (integer? x) (exact? x)))
    (define (ceiling/ n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d)) (ceiling-/- n d)]
            [(negative? n)
             (let ([n (- 0 n)])
               (values (- 0 (quotient n d)) (- 0 (remainder n d))))]
            [(negative? d)
             (let ([d (- 0 d)])
               (values (- 0 (quotient n d)) (remainder n d)))]
            [else (ceiling+/+ n d)])
          (let ([q (ceiling (/ n d))]) (values q (- n (* d q))))))
    (define (ceiling-/- n d)
      (let ([n (- 0 n)] [d (- 0 d)])
        (let ([q (quotient n d)] [r (remainder n d)])
          (if (zero? r) (values q r) (values (+ q 1) (- d r))))))
    (define (ceiling+/+ n d)
      (let ([q (quotient n d)] [r (remainder n d)])
        (if (zero? r) (values q r) (values (+ q 1) (- r d)))))
    (define (ceiling-quotient n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d))
             (receive (q r) (ceiling-/- n d) r q)]
            [(negative? n) (- 0 (quotient (- 0 n) d))]
            [(negative? d) (- 0 (quotient n (- 0 d)))]
            [else (receive (q r) (ceiling+/+ n d) r q)])
          (ceiling (/ n d))))
    (define (ceiling-remainder n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d))
             (receive (q r) (ceiling-/- n d) q r)]
            [(negative? n) (- 0 (remainder (- 0 n) d))]
            [(negative? d) (remainder n (- 0 d))]
            [else (receive (q r) (ceiling+/+ n d) q r)])
          (- n (* d (ceiling (/ n d))))))
    (define (euclidean/ n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d)) (ceiling-/- n d)]
            [(negative? n) (floor-/+ n d)]
            [(negative? d)
             (let ([d (- 0 d)])
               (values (- 0 (quotient n d)) (remainder n d)))]
            [else (values (quotient n d) (remainder n d))])
          (let ([q (if (negative? d)
                       (ceiling (/ n d))
                       (floor (/ n d)))])
            (values q (- n (* d q))))))
    (define (euclidean-quotient n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d))
             (receive (q r) (ceiling-/- n d) r q)]
            [(negative? n) (receive (q r) (floor-/+ n d) r q)]
            [(negative? d) (- 0 (quotient n (- 0 d)))]
            [else (quotient n d)])
          (if (negative? d) (ceiling (/ n d)) (floor (/ n d)))))
    (define (euclidean-remainder n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d))
             (receive (q r) (ceiling-/- n d) q r)]
            [(negative? n) (receive (q r) (floor-/+ n d) q r)]
            [(negative? d) (remainder n (- 0 d))]
            [else (remainder n d)])
          (- n
             (* d
                (if (negative? d) (ceiling (/ n d)) (floor (/ n d)))))))
    (define (floor/ n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d))
             (let ([n (- 0 n)] [d (- 0 d)])
               (values (quotient n d) (- 0 (remainder n d))))]
            [(negative? n) (floor-/+ n d)]
            [(negative? d) (floor+/- n d)]
            [else (values (quotient n d) (remainder n d))])
          (let ([q (floor (/ n d))]) (values q (- n (* d q))))))
    (define (floor-/+ n d)
      (let ([n (- 0 n)])
        (let ([q (quotient n d)] [r (remainder n d)])
          (if (zero? r)
              (values (- 0 q) r)
              (values (- (- 0 q) 1) (- d r))))))
    (define (floor+/- n d)
      (let ([d (- 0 d)])
        (let ([q (quotient n d)] [r (remainder n d)])
          (if (zero? r)
              (values (- 0 q) r)
              (values (- (- 0 q) 1) (- r d))))))
    (define (floor-quotient n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d))
             (quotient (- 0 n) (- 0 d))]
            [(negative? n) (receive (q r) (floor-/+ n d) r q)]
            [(negative? d) (receive (q r) (floor+/- n d) r q)]
            [else (quotient n d)])
          (floor (/ n d))))
    (define (floor-remainder n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d))
             (- 0 (remainder (- 0 n) (- 0 d)))]
            [(negative? n) (receive (q r) (floor-/+ n d) q r)]
            [(negative? d) (receive (q r) (floor+/- n d) q r)]
            [else (remainder n d)])
          (- n (* d (floor (/ n d))))))
    (define (round/ n d)
      (define (divide n d adjust leave)
        (let ([q (quotient n d)] [r (remainder n d)])
          (if (and (not (zero? r))
                   (or (and (odd? q)
                            (even? d)
                            (divisible? n (quotient d 2)))
                       (< d (* 2 r))))
              (adjust (+ q 1) (- r d))
              (leave q r))))
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d))
             (divide
               (- 0 n)
               (- 0 d)
               (lambda (q r) (values q (- 0 r)))
               (lambda (q r) (values q (- 0 r))))]
            [(negative? n)
             (divide
               (- 0 n)
               d
               (lambda (q r) (values (- 0 q) (- 0 r)))
               (lambda (q r) (values (- 0 q) (- 0 r))))]
            [(negative? d)
             (divide
               n
               (- 0 d)
               (lambda (q r) (values (- 0 q) r))
               (lambda (q r) (values (- 0 q) r)))]
            [else
             (let ([return (lambda (q r) (values q r))])
               (divide n d return return))])
          (let ([q (round (/ n d))]) (values q (- n (* d q))))))
    (define (divisible? n d) (zero? (remainder n d)))
    (define (round-quotient n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (receive (q r) (round/ n d) r q)
          (round (/ n d))))
    (define (round-remainder n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (receive (q r) (round/ n d) q r)
          (- n (* d (round (/ n d))))))
    (define (truncate/ n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d))
             (let ([n (- 0 n)] [d (- 0 d)])
               (values (quotient n d) (- 0 (remainder n d))))]
            [(negative? n)
             (let ([n (- 0 n)])
               (values (- 0 (quotient n d)) (- 0 (remainder n d))))]
            [(negative? d)
             (let ([d (- 0 d)])
               (values (- 0 (quotient n d)) (remainder n d)))]
            [else (values (quotient n d) (remainder n d))])
          (let ([q (truncate (/ n d))]) (values q (- n (* d q))))))
    (define (truncate-quotient n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d))
             (quotient (- 0 n) (- 0 d))]
            [(negative? n) (- 0 (quotient (- 0 n) d))]
            [(negative? d) (- 0 (quotient n (- 0 d)))]
            [else (quotient n d)])
          (truncate (/ n d))))
    (define (truncate-remainder n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond
            [(and (negative? n) (negative? d))
             (- 0 (remainder (- 0 n) (- 0 d)))]
            [(negative? n) (- 0 (remainder (- 0 n) d))]
            [(negative? d) (remainder n (- 0 d))]
            [else (remainder n d)])
          (- n (* d (truncate (/ n d))))))
    (define (balanced/ x y)
      (call-with-values
        (lambda () (euclidean/ x y))
        (lambda (q r)
          (cond
            [(< r (abs (/ y 2))) (values q r)]
            [(> y 0) (values (+ q 1) (- x (* (+ q 1) y)))]
            [else (values (- q 1) (- x (* (- q 1) y)))]))))
    (define (balanced-quotient x y)
      (call-with-values
        (lambda () (balanced/ x y))
        (lambda (q r) q)))
    (define (balanced-remainder x y)
      (call-with-values
        (lambda () (balanced/ x y))
        (lambda (q r) r)))))
