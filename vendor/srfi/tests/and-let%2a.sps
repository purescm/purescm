;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: ./tests/and-let%2a.sps
#!r6rs
;; Copyright 2010 Derick Eddington.  My MIT-style license is in the file named
;; LICENSE from the original collection this file is distributed with.
(import
  (rnrs)
  (rnrs eval)
  (srfi :2 and-let*)
  (srfi :78 lightweight-testing))
(define-syntax expect
  (syntax-rules () [(_ expr result) (check expr => result)]))
(define-syntax must-be-a-syntax-error
  (syntax-rules ()
    [(_ expr)
     (check
       (guard (ex [#t (syntax-violation? ex)])
         (eval 'expr (environment '(rnrs) '(srfi :2 and-let*)))
         'unexpected-return)
       =>
       #t)]))
(expect (and-let* () 1) 1)
(expect (and-let* () 1 2) 2)
(expect (and-let* ()) #t)
(expect (let ([x #f]) (and-let* (x))) #f)
(expect (let ([x 1]) (and-let* (x))) 1)
(expect (and-let* ((x #f))) #f)
(expect (and-let* ((x 1))) 1)
(must-be-a-syntax-error (and-let* (#f (x 1))))
(expect (and-let* ((#f) (x 1))) #f)
(must-be-a-syntax-error (and-let* (2 (x 1))))
(expect (and-let* ((2) (x 1))) 1)
(expect (and-let* ((x 1) (2))) 2)
(expect (let ([x #f]) (and-let* (x) x)) #f)
(expect (let ([x ""]) (and-let* (x) x)) "")
(expect (let ([x ""]) (and-let* (x))) "")
(expect (let ([x 1]) (and-let* (x) (+ x 1))) 2)
(expect (let ([x #f]) (and-let* (x) (+ x 1))) #f)
(expect
  (let ([x 1]) (and-let* (((positive? x))) (+ x 1)))
  2)
(expect (let ([x 1]) (and-let* (((positive? x))))) #t)
(expect
  (let ([x 0]) (and-let* (((positive? x))) (+ x 1)))
  #f)
(expect
  (let ([x 1])
    (and-let* (((positive? x)) (x (+ x 1))) (+ x 1)))
  3)
(expect
  (let ([x 1]) (and-let* (x ((positive? x))) (+ x 1)))
  2)
(expect
  (let ([x 1])
    (and-let* (((begin x)) ((positive? x))) (+ x 1)))
  2)
(expect
  (let ([x 0]) (and-let* (x ((positive? x))) (+ x 1)))
  #f)
(expect
  (let ([x #f]) (and-let* (x ((positive? x))) (+ x 1)))
  #f)
(expect
  (let ([x #f])
    (and-let* (((begin x)) ((positive? x))) (+ x 1)))
  #f)
(expect
  (let ([x 1])
    (and-let* (x (y (- x 1)) ((positive? y))) (/ x y)))
  #f)
(expect
  (let ([x 0])
    (and-let* (x (y (- x 1)) ((positive? y))) (/ x y)))
  #f)
(expect
  (let ([x #f])
    (and-let* (x (y (- x 1)) ((positive? y))) (/ x y)))
  #f)
(expect
  (let ([x 3])
    (and-let* (x (y (- x 1)) ((positive? y))) (/ x y)))
  3/2)
(must-be-a-syntax-error (and-let* (("oops" 1))))
(must-be-a-syntax-error (and-let* ((x 1 2))))
(must-be-a-syntax-error (and-let* ((x 1) . oops)))
(expect
  (let ([x 1])
    (and-let* ((x (+ x 1)) (x (+ x 1)) (x (+ x 1))) (+ x 1)))
  5)
(expect (and-let* () (define x 1) (- x)) -1)
(expect
  (and-let* ((x 2) (y (+ 1 x))) (define z (* x y)) (/ z))
  1/6)
(check-report)
