;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: ./tests/cut.sps
#!r6rs
;; Copyright 2010 Derick Eddington.  My MIT-style license is in the file named
;; LICENSE from the original collection this file is distributed with.
;;;;;; File header: %3a26/check.scm
; CONFIDENCE TEST FOR IMPLEMENTATION OF SRFI-26
; =============================================
;
; Sebastian.Egner@philips.com, 3-Jun-2002.
;
; This file checks a few assertions about the implementation.
; If you run it and no error message is issued, the implementation
; is correct on the cases that have been tested.
;
; compliance:
;   Scheme R5RS with
;     SRFI-23: error
;
; loading this file into Scheme 48 0.57 after 'cut.scm' has been loaded:
;   ,open srfi-23
;   ,load check.scm
(import
  (except (rnrs) display newline)
  (srfi :78 lightweight-testing)
  (srfi private include)
  (srfi :26 cut))
(define (ignore . _) (values))
(define display ignore)
(define newline ignore)
(define check-all ignore)
(let-syntax ([define (syntax-rules (check check-all for-each
                                    quote equal?)
                       [(_ (check _) . _) (begin)]
                       [(_ (check-all)
                           (for-each check '((equal? expr val) ...)))
                        (begin (check expr => val) ...)])])
  (begin
    (define (check expr)
      (if (not (eq? (eval expr (interaction-environment)) #t))
          (error "check failed" expr)))
    (define (check-all)
      (for-each
        check
        '((equal? ((cut list)) '()) (equal? ((cut list <...>)) '())
          (equal? ((cut list 1)) '(1)) (equal? ((cut list <>) 1) '(1))
          (equal? ((cut list <...>) 1) '(1))
          (equal? ((cut list 1 2)) '(1 2))
          (equal? ((cut list 1 <>) 2) '(1 2))
          (equal? ((cut list 1 <...>) 2) '(1 2))
          (equal? ((cut list 1 <...>) 2 3 4) '(1 2 3 4))
          (equal? ((cut list 1 <> 3 <>) 2 4) '(1 2 3 4))
          (equal? ((cut list 1 <> 3 <...>) 2 4 5 6) '(1 2 3 4 5 6))
          (equal?
            (let* ([x 'wrong] [y (cut list x)]) (set! x 'ok) (y))
            '(ok))
          (equal?
            (let ([a 0])
              (map (cut + (begin (set! a (+ a 1)) a) <>) '(1 2))
              a)
            2)
          (equal? ((cute list)) '()) (equal? ((cute list <...>)) '())
          (equal? ((cute list 1)) '(1))
          (equal? ((cute list <>) 1) '(1))
          (equal? ((cute list <...>) 1) '(1))
          (equal? ((cute list 1 2)) '(1 2))
          (equal? ((cute list 1 <>) 2) '(1 2))
          (equal? ((cute list 1 <...>) 2) '(1 2))
          (equal? ((cute list 1 <...>) 2 3 4) '(1 2 3 4))
          (equal? ((cute list 1 <> 3 <>) 2 4) '(1 2 3 4))
          (equal? ((cute list 1 <> 3 <...>) 2 4 5 6) '(1 2 3 4 5 6))
          (equal?
            (let* ([x 'ok] [y (cute list x)]) (set! x 'wrong) (y))
            '(ok))
          (equal?
            (let ([a 0])
              (map (cute + (begin (set! a (+ a 1)) a) <>) '(1 2))
              a)
            1))))
    (check-all)
    (display "passed")
    (newline)))
(check
  (let* ([<> 'wrong] [f (cut list <> <...>)])
    (set! <> 'ok)
    (f 1 2))
  =>
  '(ok 1 2))
(check
  (let* ([<...> 'wrong] [f (cut list <> <...>)])
    (set! <...> 'ok)
    (f 1))
  =>
  '(1 ok))
(check
  (let* ([<> 'ok] [f (cute list <> <...>)])
    (set! <> 'wrong)
    (f 1 2))
  =>
  '(ok 1 2))
(check
  (let* ([<...> 'ok] [f (cute list <> <...>)])
    (set! <...> 'wrong)
    (f 1))
  =>
  '(1 ok))
(check-report)
