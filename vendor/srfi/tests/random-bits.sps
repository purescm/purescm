;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: ./tests/random-bits.sps
#!r6rs
;; Copyright 2010 Derick Eddington.  My MIT-style license is in the file named
;; LICENSE from the original collection this file is distributed with.
;;;;;; File header: %3a27/conftest.scm
; CONFIDENCE TESTS FOR SRFI-27 "Sources of Random Bits"
; =====================================================
;
; Sebastian.Egner@philips.com, 2002.
;
; This file contains a small collection of checks for the
; implementation of SRFI-27. It is not meant to be complete
; or to test the actual properties of the underlying generator.
; It is merely meant to run the code and to check some of the
; assumptions made by specification. There is an interface to
; G. Marsaglia's DIEHARD battery of tests for random number
; generators, though.
;
; running this file in Scheme 48 0.57 with SRFI-27 installed:
;
;   ,open srfi-27 srfi-23 ascii
;   ,load conftest.scm
;
; speed in Scheme 48 0.57 with SRFI-27 opened:
;
;   ,time (do ((k 0 (+ k 1))) ((= k 100000)) (random-integer 2))
;   ; about  30000/s on P3@800MHz for the Scheme-impl.
;   ; about 160000/s on P3@800MHz for the C/Scheme-impl.
;
;   ,time (do ((k 0 (+ k 1))) ((= k 100000)) (random-real))
;   ; about   3000/s on P3@800MHz for the Scheme-impl.
;   ; about 180000/s on P3@800MHz for the C/Scheme-impl.
;
; running this file in Gambit 3.0 (interpreter) with SRFI-27 loaded:
;
;   (define ascii->char integer->char)
;   (load "conftest.scm")
;
; compiling a simple program in Gambit 3.0 (compiler) using this file:
;
;   1. create 'a.scm' with content;
;     (include "srfi-27-c.scm")
;     (time (do ((k 0 (+ k 1))) ((= k 1000000)) (random-integer 2)))
;     (time (do ((k 0 (+ k 1))) ((= k 1000000)) (random-real)))
;   2. compile Scheme into C (verbose paths for clarity)
;     GAMBCDIR=$GAMBIT/lib LD_LIBRARY_PATH=$GAMBIT/lib $GAMBIT/gsc/gsc a
;   3. compile and link C code into an executable
;     gcc -I$GAMBIT/lib -o a a.c a_.c -lm -lgambc -L$GAMBIT/lib
;   4. run the executable
;     GAMBCDIR=$GAMBIT/lib LD_LIBRARY_PATH=$GAMBIT/lib a
;
; speed in Gambit 3.0 with SRFI-27 loaded:
;
;   (time (do ((k 0 (+ k 1))) ((= k 100000)) (random-integer 2)))
;   ; about 5000/s on P3@800MHz, interpreted
;   ; about 200000/s on P3@800MHz, compiled
;
;   (time (do ((k 0 (+ k 1))) ((= k 100000)) (random-real)))
;   ; about 25000/s on P3@800MHz, interpreted
;   ; about 400000/s on P3@800MHz, compiled
;
; history of this file:
;   SE, 19-Mar-2002: initial version, based on earlier tests
;   SE, 22-Mar-2002: adapted to new procedure names
;   SE, 25-Mar-2002: more descriptive output
;   SE, 04-Apr-2002: some quick timings; check up
(import (except (rnrs) error) (rnrs r5rs) (srfi :23 error)
  (srfi private include) (srfi :27 random-bits))
(define eval 'ignore)
(define interaction-environment 'ignore)
(define ascii->char integer->char)
(begin
  (define (check expr)
    (if (not (eq? (eval expr (interaction-environment)) #t))
        (error "check failed" expr)))
  (define (my-random-integer n)
    (let ([x (random-integer n)])
      (if (<= 0 x (- n 1))
          x
          (error "(random-integer n) returned illegal value" x))))
  (define (my-random-real)
    (let ([x (random-real)])
      (if (< 0 x 1)
          x
          (error "(random-real) returned illegal value" x))))
  (define (check-basics-1)
    (display "; generating large numbers [bits]: ")
    (do ([k 0 (+ k 1)] [n 1 (* n 2)])
        ((> k 1024))
      (display k)
      (display " ")
      (my-random-integer n))
    (display "ok")
    (newline)
    (display "; generating reals [1000 times]: ")
    (do ([k 0 (+ k 1)]
         [x (my-random-real) (+ x (my-random-real))])
        ((= k 1000) x))
    (display "ok")
    (newline)
    (display "; get/set state: ")
    (let* ([state1 (random-source-state-ref
                     default-random-source)]
           [x1 (my-random-integer (expt 2 32))]
           [state2 (random-source-state-ref default-random-source)]
           [x2 (my-random-integer (expt 2 32))])
      (random-source-state-set! default-random-source state1)
      (let ([y1 (my-random-integer (expt 2 32))])
        (if (not (= x1 y1))
            (error "state get/set doesn't work" x1 y1 state1)))
      (random-source-state-set! default-random-source state2)
      (let ([y2 (my-random-integer (expt 2 32))])
        (if (not (= x2 y2))
            (error "state get/set doesn't work" x2 y2 state2))))
    (display "ok")
    (newline)
    (display "; randomize!: ")
    (let* ([state1 (random-source-state-ref
                     default-random-source)]
           [x1 (my-random-integer (expt 2 32))])
      (random-source-state-set! default-random-source state1)
      (random-source-randomize! default-random-source)
      (let ([y1 (my-random-integer (expt 2 32))])
        (if (= x1 y1)
            (error "random-source-randomize! didn't work" x1 state1))))
    (display "ok")
    (newline)
    (display "; pseudo-randomize!: ")
    (let* ([state1 (random-source-state-ref
                     default-random-source)]
           [x1 (my-random-integer (expt 2 32))])
      (random-source-state-set! default-random-source state1)
      (random-source-pseudo-randomize! default-random-source 0 1)
      (let ([y1 (my-random-integer (expt 2 32))])
        (if (= x1 y1)
            (error "random-source-pseudo-randomize! didn't work"
              x1
              state1)))
      (random-source-state-set! default-random-source state1)
      (random-source-pseudo-randomize! default-random-source 1 0)
      (let ([y1 (my-random-integer (expt 2 32))])
        (if (= x1 y1)
            (error "random-source-pseudo-randomize! didn't work"
              x1
              state1))))
    (display "ok")
    (newline)
    (newline))
  (define (check-mrg32k3a)
    (display "; check A^16 * (1 0 0 1 0 0)")
    (let* ([s (make-random-source)]
           [state1 (random-source-state-ref s)]
           [rand (random-source-make-reals s)])
      (random-source-state-set! s '(lecuyer-mrg32k3a 1 0 0 1 0 0))
      (do ([k 0 (+ k 1)])
          ((= k 16)
           (let ([state2 (random-source-state-ref s)])
             (if (not (equal? state1 state2))
                 (error "16-th state after (1 0 0 1 0 0) is wrong"))))
        (rand)))
    (display "ok")
    (newline)
    (display
      "; checking (random-source-pseudo-randomize! s 1 2)")
    (let ([s (make-random-source)])
      (random-source-pseudo-randomize! s 1 2)
      (if (not (equal?
                 (random-source-state-ref s)
                 '(lecuyer-mrg32k3a 1250826159 3004357423 431373563
                    3322526864 623307378 2983662421)))
          (error "pseudo-randomize! gives wrong result")))
    (display "ok")
    (newline)
    (display
      "; checking (random-source-pseudo-randomize! s 1 2)...")
    (let* ([x 0.0]
           [s (make-random-source)]
           [rand (random-source-make-reals s)])
      (random-source-state-set!
        s
        '(lecuyer-mrg32k3a 12345 12345 12345 12345 12345 12345))
      (do ([k 0 (+ k 1)])
          ((= k 10000000)
           (if (not (< (abs (- x 5001090.95)) 0.01))
               (error "bad sum over 10^7 reals" x)))
        (set! x (+ x (rand)))))
    (display "ok")
    (newline))
  (define (write-diehard filename s bytes-per-call calls)
    (let ([port (open-output-file filename)]
          [rand (random-source-make-integers s)]
          [n (expt 256 bytes-per-call)])
      (do ([i 0 (+ i 1)])
          ((= i calls) (close-output-port port))
        (let ([x (rand n)])
          (do ([k 0 (+ k 1)])
              ((= k bytes-per-call))
            (write-char (ascii->char (modulo x 256)) port)
            (set! x (quotient x 256)))))))
  (check-basics-1)
  (display "passed (check-basics-1)")
  (newline))
(check-mrg32k3a)
(display "passed (check-mrg32k3a)\n")
