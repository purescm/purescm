;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: %3a125/hashtables.sls
;;;;;; File header: %3a125/125.body.scm
;;; Copyright 2015 William D Clinger.
;;;
;;; Permission to copy this software, in whole or in part, to use this
;;; software for any lawful purpose, and to redistribute this software
;;; is granted subject to the restriction that all copies made of this
;;; software must include this copyright and permission notice in full.
;;;
;;; I also request that you send me a copy of any improvements that you
;;; make to this software so that they may be incorporated within it to
;;; the benefit of the Scheme community.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(library (srfi :125 hashtables)
  (export make-hash-table hash-table hash-table-unfold
   alist->hash-table hash-table? hash-table-contains?
   hash-table-empty? hash-table=? hash-table-mutable?
   hash-table-ref hash-table-ref/default hash-table-set!
   hash-table-delete! hash-table-intern! hash-table-update!
   hash-table-update!/default hash-table-pop! hash-table-clear!
   hash-table-size hash-table-keys hash-table-values
   hash-table-entries hash-table-find hash-table-count
   hash-table-map hash-table-for-each hash-table-map!
   hash-table-map->list hash-table-fold hash-table-prune!
   hash-table-copy hash-table-empty-copy hash-table->alist
   hash-table-union! hash-table-intersection!
   hash-table-difference! hash-table-xor! deprecated:hash
   deprecated:string-hash deprecated:string-ci-hash
   deprecated:hash-by-identity
   deprecated:hash-table-equivalence-function
   deprecated:hash-table-hash-function
   deprecated:hash-table-exists? deprecated:hash-table-walk
   deprecated:hash-table-merge!)
  (import
    (except (rnrs) make-hashtable hashtable-clear! hashtable-copy
      hashtable-ref hashtable-update! make-eq-hashtable
      make-eqv-hashtable)
    (srfi private include)
    (rename (srfi :126) (hashtable? hash-table?)
      (hashtable-contains? hash-table-contains?)
      (hashtable-empty? hash-table-empty?)
      (hashtable-intern! hash-table-intern!)
      (hashtable-clear! hash-table-clear!)
      (hashtable-copy hash-table-copy)
      (hashtable-size hash-table-size)
      (hashtable-pop! hash-table-pop!)
      (hashtable-merge! hash-table-merge!)
      (hashtable-hash-function hash-table-hash-function)
      (hashtable-equivalence-function
        hash-table-equivalence-function))
    (except (srfi :128) hash-salt string-hash string-ci-hash
      symbol-hash))
  (begin
    (define (issue-deprecated-warnings?) #t)
    (define (issue-warning-deprecated
             name-of-deprecated-misfeature)
      (if (not (memq
                 name-of-deprecated-misfeature
                 already-warned))
          (begin
            (set! already-warned
              (cons name-of-deprecated-misfeature already-warned))
            (if (issue-deprecated-warnings?)
                (let ([out (current-error-port)])
                  (display "WARNING: " out)
                  (display name-of-deprecated-misfeature out)
                  (newline out)
                  (display "    is deprecated by SRFI 125.  See" out)
                  (newline out)
                  (display "    " out)
                  (display url:deprecated out)
                  (newline out))))))
    (define url:deprecated
      "http://srfi.schemers.org/srfi-125/srfi-125.html")
    (define already-warned '())
    (define %enforce-comparator-type-tests #t)
    (define (%comparator-hash-function comparator)
      (let ([okay? (comparator-type-test-predicate comparator)]
            [hash-function (comparator-hash-function comparator)])
        (if %enforce-comparator-type-tests
            (lambda (x . rest)
              (cond
                [(not (okay? x))
                 (error #f
                   "key rejected by hash-table comparator"
                   x
                   comparator)]
                [(null? rest) (hash-function x)]
                [else (apply hash-function x rest)]))
            hash-function)))
    (define %not-found (list '%not-found))
    (define %not-found-irritant (list 'not-found))
    (define %not-found-message "hash-table key not found")
    (define (%check-optional-arguments procname args)
      (if (memq 'thread-safe args)
          (error (string-append
                   (symbol->string procname)
                   ": unsupported optional argument(s)")
            args)))
    (define (%get-hash-table-weakness args)
      (cond
        [(memq 'ephemeral-values args)
         (if (or (memq 'ephemeral-keys args) (memq 'weak-keys args))
             'ephemeral-key-and-value
             'ephemeral-value)]
        [(memq 'ephemeral-keys args)
         (if (memq 'weak-values args)
             'ephemeral-key-and-value
             'ephemeral-key)]
        [(memq 'weak-keys args)
         (if (memq 'weak-values args) 'weak-key-and-value 'weak-key)]
        [(memq 'weak-values args) 'weak-value]
        [else #f]))
    (define (%get-hash-table-capacity args) (find fixnum? args))
    (define (hash-table-every proc ht)
      (call-with-values
        (lambda () (hashtable-entries ht))
        (lambda (keys vals)
          (let ([size (vector-length keys)])
            (let loop ([i 0])
              (or (fx>=? i size)
                  (let* ([key (vector-ref keys i)]
                         [val (vector-ref vals i)])
                    (and (proc key val) (loop (fx+ i 1))))))))))
    (define (make-hash-table comparator/equiv . rest)
      (if (comparator? comparator/equiv)
          (let ([equiv (comparator-equality-predicate
                         comparator/equiv)]
                [hash-function (%comparator-hash-function
                                 comparator/equiv)])
            (%make-hash-table equiv hash-function rest))
          (let* ([equiv comparator/equiv]
                 [hash-function (if (and (not (null? rest))
                                         (procedure? (car rest)))
                                    (car rest)
                                    #f)]
                 [rest (if hash-function (cdr rest) rest)])
            (issue-warning-deprecated 'srfi-69-style:make-hash-table)
            (%make-hash-table equiv hash-function rest))))
    (define (%make-hash-table equiv hash-function opts)
      (%check-optional-arguments 'make-hash-table opts)
      (let ([weakness (%get-hash-table-weakness opts)]
            [capacity (%get-hash-table-capacity opts)])
        (cond
          [(equal? equiv eq?) (make-eq-hashtable capacity weakness)]
          [(equal? equiv eqv?) (make-eqv-hashtable capacity weakness)]
          [hash-function
           (make-hashtable hash-function equiv capacity weakness)]
          [(equal? equiv equal?)
           (make-hashtable equal-hash equiv capacity weakness)]
          [(equal? equiv string=?)
           (make-hashtable string-hash equiv capacity weakness)]
          [(equal? equiv string-ci=?)
           (make-hashtable string-ci-hash equiv capacity weakness)]
          [(equal? equiv symbol=?)
           (make-hashtable symbol-hash equiv capacity weakness)]
          [else
           (error "make-hash-table: unable to infer hash function"
             equiv)])))
    (define (hash-table comparator . rest)
      (let ([ht (apply make-hash-table comparator rest)])
        (let loop ([kvs rest])
          (cond
            [(null? kvs) #f]
            [(null? (cdr kvs))
             (error #f "hash-table: wrong number of arguments")]
            [(hashtable-contains? ht (car kvs))
             (error "hash-table: two equivalent keys were provided"
               (car kvs))]
            [else
             (hashtable-set! ht (car kvs) (cadr kvs))
             (loop (cddr kvs))]))
        (hash-table-copy ht #f)))
    (define (hash-table-unfold stop? mapper successor seed
             comparator . rest)
      (let ([ht (apply make-hash-table comparator rest)])
        (let loop ([seed seed])
          (if (stop? seed)
              ht
              (call-with-values
                (lambda () (mapper seed))
                (lambda (key val)
                  (hash-table-set! ht key val)
                  (loop (successor seed))))))))
    (define (alist->hash-table alist comparator/equiv . rest)
      (if (and (not (null? rest)) (procedure? (car rest)))
          (issue-warning-deprecated 'srfi-69-style:alist->hash-table))
      (let ([ht (apply make-hash-table comparator/equiv rest)]
            [entries (reverse alist)])
        (for-each
          (lambda (entry)
            (hash-table-set! ht (car entry) (cdr entry)))
          entries)
        ht))
    (define (hash-table=? value-comparator ht1 ht2)
      (let ([val=? (comparator-equality-predicate
                     value-comparator)]
            [n1 (hash-table-size ht1)]
            [n2 (hash-table-size ht2)])
        (and (= n1 n2)
             (eq? (hashtable-equivalence-function ht1)
                  (hashtable-equivalence-function ht2))
             (hash-table-every
               (lambda (key val1)
                 (and (hash-table-contains? ht2 key)
                      (val=? val1 (hashtable-ref ht2 key 'ignored))))
               ht1))))
    (define (hash-table-mutable? ht) (hashtable-mutable? ht))
    (define hash-table-ref
      (case-lambda
        [(ht key) (hashtable-ref ht key)]
        [(ht key failure)
         (let ([val (hashtable-ref ht key %not-found)])
           (if (eq? val %not-found) (failure) val))]
        [(ht key failure success)
         (let ([val (hashtable-ref ht key %not-found)])
           (if (eq? val %not-found) (failure) (success val)))]))
    (define (hash-table-ref/default ht key default)
      (hashtable-ref ht key default))
    (define hash-table-set!
      (case-lambda
        [(ht) #f]
        [(ht key val) (hashtable-set! ht key val)]
        [(ht key1 val1 key2 val2 . others)
         (hashtable-set! ht key1 val1)
         (hashtable-set! ht key2 val2)
         (apply hash-table-set! ht others)]))
    (define (hash-table-delete! ht . keys)
      (let ([count 0])
        (for-each
          (lambda (key)
            (when (hashtable-contains? ht key)
              (set! count (fx+ 1 count))
              (hashtable-delete! ht key)))
          keys)
        count))
    (define hash-table-update!
      (case-lambda
        [(ht key updater) (hashtable-update! ht key updater)]
        [(ht key updater failure)
         (let ([updater* (lambda (val)
                           (if (eq? %not-found val)
                               (updater (failure))
                               (updater val)))])
           (hashtable-update! ht key updater* %not-found))]
        [(ht key updater failure success)
         (let* ([updater* (lambda (val)
                            (if (eq? %not-found val)
                                (updater (failure))
                                (success (updater val))))])
           (hashtable-update! ht key updater* %not-found))]))
    (define (hash-table-update!/default ht key updater default)
      (hashtable-update! ht key updater default))
    (define (hash-table-keys ht)
      (vector->list (hashtable-keys ht)))
    (define (hash-table-values ht)
      (vector->list (hashtable-values ht)))
    (define (hash-table-entries ht)
      (call-with-values
        (lambda () (hashtable-entries ht))
        (lambda (keys vals)
          (values (vector->list keys) (vector->list vals)))))
    (define (hash-table-find proc ht failure)
      (call-with-values
        (lambda () (hashtable-entries ht))
        (lambda (keys vals)
          (let ([size (vector-length keys)])
            (let loop ([i 0])
              (if (fx>=? i size)
                  (failure)
                  (let* ([key (vector-ref keys i)]
                         [val (vector-ref vals i)]
                         [x (proc key val)])
                    (or x (loop (fx+ i 1))))))))))
    (define (hash-table-count pred ht)
      (let ([count 0])
        (call-with-values
          (lambda () (hashtable-entries ht))
          (lambda (keys vals)
            (vector-for-each
              (lambda (key val)
                (if (pred key val) (set! count (fx+ count 1))))
              keys
              vals)))
        count))
    (define (hash-table-map proc comparator ht)
      (let ([result (make-hash-table comparator)])
        (hash-table-for-each
          (lambda (key val) (hash-table-set! result key (proc val)))
          ht)
        result))
    (define (hash-table-map->list proc ht)
      (call-with-values
        (lambda () (hash-table-entries ht))
        (lambda (keys vals) (map proc keys vals))))
    (define (hash-table-for-each proc ht)
      (hashtable-walk ht proc))
    (define (hash-table-map! proc ht)
      (hashtable-update-all! ht proc))
    (define (hash-table-fold proc init ht)
      (if (hashtable? proc)
          (deprecated:hash-table-fold proc init ht)
          (hashtable-sum ht init proc)))
    (define (hash-table-prune! proc ht)
      (hashtable-prune! ht proc))
    (define (hash-table-empty-copy ht)
      (let* ([ht2 (hash-table-copy ht #t)]
             [ignored (hash-table-clear! ht2)])
        ht2))
    (define (hash-table->alist ht)
      (call-with-values
        (lambda () (hash-table-entries ht))
        (lambda (keys vals) (map cons keys vals))))
    (define (hash-table-union! ht1 ht2)
      (hash-table-for-each
        (lambda (key2 val2)
          (if (not (hashtable-contains? ht1 key2))
              (hashtable-set! ht1 key2 val2)))
        ht2)
      ht1)
    (define (hash-table-intersection! ht1 ht2)
      (hash-table-for-each
        (lambda (key1 val1)
          (if (not (hashtable-contains? ht2 key1))
              (hashtable-delete! ht1 key1)))
        ht1)
      ht1)
    (define (hash-table-difference! ht1 ht2)
      (hash-table-for-each
        (lambda (key1 val1)
          (if (hashtable-contains? ht2 key1)
              (hashtable-delete! ht1 key1)))
        ht1)
      ht1)
    (define (hash-table-xor! ht1 ht2)
      (hash-table-for-each
        (lambda (key2 val2)
          (if (hashtable-contains? ht1 key2)
              (hashtable-delete! ht1 key2)
              (hashtable-set! ht1 key2 val2)))
        ht2)
      ht1)
    (define (deprecated:hash obj . rest)
      (issue-warning-deprecated 'hash)
      (default-hash obj))
    (define (deprecated:string-hash obj . rest)
      (issue-warning-deprecated 'srfi-125:string-hash)
      (string-hash obj))
    (define (deprecated:string-ci-hash obj . rest)
      (issue-warning-deprecated 'srfi-125:string-ci-hash)
      (string-ci-hash obj))
    (define (deprecated:hash-by-identity obj . rest)
      (issue-warning-deprecated 'hash-by-identity)
      (deprecated:hash obj))
    (define (deprecated:hash-table-equivalence-function ht)
      (issue-warning-deprecated 'hash-table-equivalence-function)
      (hashtable-equivalence-function ht))
    (define (deprecated:hash-table-hash-function ht)
      (issue-warning-deprecated 'hash-table-hash-function)
      (hashtable-hash-function ht))
    (define (deprecated:hash-table-exists? ht key)
      (issue-warning-deprecated 'hash-table-exists?)
      (hash-table-contains? ht key))
    (define (deprecated:hash-table-walk ht proc)
      (issue-warning-deprecated 'hash-table-walk)
      (hash-table-for-each proc ht))
    (define (deprecated:hash-table-fold ht proc seed)
      (issue-warning-deprecated 'srfi-69-style:hash-table-fold)
      (hash-table-fold proc seed ht))
    (define (deprecated:hash-table-merge! ht1 ht2)
      (issue-warning-deprecated 'hash-table-merge!)
      (hash-table-union! ht1 ht2))))
