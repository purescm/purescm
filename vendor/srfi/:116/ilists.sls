;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: %3a116/ilists.sls
(library (srfi :116 ilists)
  (export iq ipair ilist xipair ipair* make-ilist ilist-copy
   ilist-tabulate iiota ipair? proper-ilist? ilist?
   dotted-ilist? not-ipair? null-ilist? ilist= icar icdr
   ilist-ref ifirst isecond ithird ifourth ififth isixth
   iseventh ieighth ininth itenth icaar icadr icdar icddr
   icaaar icaadr icadar icaddr icdaar icdadr icddar icdddr
   icaaaar icaaadr icaadar icaaddr icadaar icadadr icaddar
   icadddr icdaaar icdaadr icdadar icdaddr icddaar icddadr
   icdddar icddddr icar+icdr itake idrop ilist-tail itake-right
   idrop-right isplit-at ilast last-ipair ilength iappend
   iconcatenate ireverse iappend-reverse izip iunzip1 iunzip2
   iunzip3 iunzip4 iunzip5 icount imap ifor-each ifold iunfold
   ipair-fold ireduce ifold-right iunfold-right
   ipair-fold-right ireduce-right iappend-map ipair-for-each
   ifilter-map imap-in-order ifilter ipartition iremove imember
   imemq imemv ifind ifind-tail iany ievery ilist-index
   itake-while idrop-while ispan ibreak idelete
   idelete-duplicates iassoc iassq iassv ialist-cons
   ialist-delete replace-icar replace-icdr pair->ipair
   ipair->pair list->ilist ilist->list tree->itree itree->tree
   gtree->itree gtree->tree iapply)
  (import
    (except (rnrs) define-record-type)
    (only (srfi :1) set-cdr! set-car!)
    (srfi :9))
  (define (error* msg . args) (error 'ilist msg args))
  (define-record-type <ilist>
    (ipair icar icdr)
    ipair?
    (icar icar)
    (icdr icdr))
  (define-syntax receive
    (syntax-rules ()
      [(receive formals expression body ...)
       (call-with-values
         (lambda () expression)
         (lambda formals body ...))]))
  (define-syntax iq
    (syntax-rules () [(iq . tree) (gtree->itree 'tree)]))
  (define (replace-icar old new) (ipair new (icdr old)))
  (define (replace-icdr old new) (ipair (icar old) new))
  (define (pair->ipair pair) (ipair (car pair) (cdr pair)))
  (define (ipair->pair ipair)
    (cons (icar ipair) (icdr ipair)))
  (define (list->ilist list)
    (let lp ([list list])
      (if (pair? list) (ipair (car list) (lp (cdr list))) list)))
  (define (ilist . objs) (list->ilist objs))
  (define (ilist->list ilist)
    (let lp ([ilist ilist])
      (if (ipair? ilist)
          (cons (icar ilist) (lp (icdr ilist)))
          ilist)))
  (define (tree->itree obj)
    (if (pair? obj)
        (ipair (tree->itree (car obj)) (tree->itree (cdr obj)))
        obj))
  (define (itree->tree obj)
    (if (ipair? obj)
        (cons (itree->tree (icar obj)) (itree->tree (icdr obj)))
        obj))
  (define (gtree->itree obj)
    (cond
      [(pair? obj)
       (ipair (gtree->itree (car obj)) (gtree->itree (cdr obj)))]
      [(ipair? obj)
       (ipair (gtree->itree (icar obj)) (gtree->itree (icdr obj)))]
      [else obj]))
  (define (gtree->tree obj)
    (cond
      [(pair? obj)
       (cons (gtree->tree (car obj)) (gtree->tree (cdr obj)))]
      [(ipair? obj)
       (cons (gtree->tree (icar obj)) (gtree->tree (icdr obj)))]
      [else obj]))
  (define (take! ls i)
    (if (<= i 0)
        '()
        (let ([tail (list-tail ls (- i 1))])
          (set-cdr! tail '())
          ls)))
  (define (drop-right! ls i) (take! ls (- (length ls) i)))
  (define (last ls)
    (if (null? (cdr ls)) (car ls) (last (cdr ls))))
  (define (iapply proc . ilists)
    (cond
      [(null? ilists) (apply proc '())]
      [(null? (cdr ilists))
       (apply proc (ilist->list (car ilists)))]
      [else
       (let ([final (ilist->list (last ilists))])
         (apply proc (append (drop-right! ilists 1) final)))]))
  (define (write-ipair ipair port)
    (write (gtree->tree ipair) port))
  (define-syntax :optional
    (syntax-rules ()
      [(:optional rest default)
       (cond
         [(null? rest) default]
         [(null? (cdr rest)) (car rest)]
         [else (error* "Too many arguments")])]))
  (define (iassq x lis)
    (ifind (lambda (entry) (eq? x (icar entry))) lis))
  (define (iassv x lis)
    (ifind (lambda (entry) (eqv? x (icar entry))) lis))
  (define (ifor-each proc lis1 . lists)
    (check-arg procedure? proc ipair-for-each)
    (if (pair? lists)
        (let lp ([lists (cons lis1 lists)])
          (let ([tails (%cdrs lists)])
            (if (pair? tails)
                (begin (apply proc (map icar lists)) (lp tails)))))
        (let lp ([lis lis1])
          (if (not (null-ilist? lis))
              (let ([tail (icdr lis)]) (proc (icar lis)) (lp tail))))))
  (define (check-arg pred val caller)
    (let lp ([val val])
      (if (pred val)
          val
          (lp (error* "Bad argument" val pred caller)))))
  (define (xipair d a) (ipair a d))
  (define (make-ilist len . maybe-elt)
    (check-arg
      (lambda (n) (and (integer? n) (>= n 0)))
      len
      make-ilist)
    (let ([elt (cond
                 [(null? maybe-elt) #f]
                 [(null? (cdr maybe-elt)) (car maybe-elt)]
                 [else
                  (error*
                    "Too many arguments to MAKE-ILIST"
                    (ipair len maybe-elt))])])
      (do ([i len (- i 1)] [ans '() (ipair elt ans)])
          ((<= i 0) ans))))
  (define (ilist-tabulate len proc)
    (check-arg
      (lambda (n) (and (integer? n) (>= n 0)))
      len
      ilist-tabulate)
    (check-arg procedure? proc ilist-tabulate)
    (do ([i (- len 1) (- i 1)] [ans '() (ipair (proc i) ans)])
        ((< i 0) ans)))
  (define (ipair* ifirst . rest)
    (let recur ([x ifirst] [rest rest])
      (if (pair? rest)
          (ipair x (recur (car rest) (cdr rest)))
          x)))
  (define (ilist-copy lis)
    (let recur ([lis lis])
      (if (ipair? lis)
          (ipair (icar lis) (recur (icdr lis)))
          lis)))
  (define (iiota count . maybe-start+step)
    (check-arg integer? count iiota)
    (if (< count 0) (error* "Negative step count" iiota count))
    (let ([start (if (pair? maybe-start+step)
                     (car maybe-start+step)
                     0)]
          [step (if (and (pair? maybe-start+step)
                         (pair? (cdr maybe-start+step)))
                    (cadr maybe-start+step)
                    1)])
      (check-arg number? start iiota)
      (check-arg number? step iiota)
      (let loop ([n 0] [r '()])
        (if (= n count)
            (ireverse r)
            (loop (+ 1 n) (ipair (+ start (* n step)) r))))))
  (define (ilist? x) (proper-ilist? x))
  (define (proper-ilist? x)
    (let lp ([x x] [lag x])
      (if (ipair? x)
          (let ([x (icdr x)])
            (if (ipair? x)
                (let ([x (icdr x)] [lag (icdr lag)])
                  (and (not (eq? x lag)) (lp x lag)))
                (null? x)))
          (null? x))))
  (define (dotted-ilist? x)
    (let lp ([x x] [lag x])
      (if (ipair? x)
          (let ([x (icdr x)])
            (if (ipair? x)
                (let ([x (icdr x)] [lag (icdr lag)])
                  (and (not (eq? x lag)) (lp x lag)))
                (not (null? x))))
          (not (null? x)))))
  (define (not-ipair? x) (not (ipair? x)))
  (define (null-ilist? l)
    (cond
      [(ipair? l) #f]
      [(null? l) #t]
      [else (error* "null-ilist?: argument out of domain" l)]))
  (define (ilist= = . ilists)
    (or (null? ilists)
        (let lp1 ([ilist-a (car ilists)] [others (cdr ilists)])
          (or (null? others)
              (let ([ilist-b (car others)] [others (cdr others)])
                (if (eq? ilist-a ilist-b)
                    (lp1 ilist-b others)
                    (let lp2 ([pair-a ilist-a] [pair-b ilist-b])
                      (if (null-ilist? pair-a)
                          (and (null-ilist? pair-b) (lp1 ilist-b others))
                          (and (not (null-ilist? pair-b))
                               (= (icar pair-a) (icar pair-b))
                               (lp2 (icdr pair-a) (icdr pair-b)))))))))))
  (define (ilength x)
    (let lp ([x x] [len 0])
      (if (ipair? x) (lp (icdr x) (+ len 1)) len)))
  (define (izip ilist1 . more-lists)
    (apply imap ilist ilist1 more-lists))
  (define (icaar x) (icar (icar x)))
  (define (icadr x) (icar (icdr x)))
  (define (icdar x) (icdr (icar x)))
  (define (icddr x) (icdr (icdr x)))
  (define (icaaar x) (icaar (icar x)))
  (define (icaadr x) (icaar (icdr x)))
  (define (icadar x) (icadr (icar x)))
  (define (icaddr x) (icadr (icdr x)))
  (define (icdaar x) (icdar (icar x)))
  (define (icdadr x) (icdar (icdr x)))
  (define (icddar x) (icddr (icar x)))
  (define (icdddr x) (icddr (icdr x)))
  (define (icaaaar x) (icaaar (icar x)))
  (define (icaaadr x) (icaaar (icdr x)))
  (define (icaadar x) (icaadr (icar x)))
  (define (icaaddr x) (icaadr (icdr x)))
  (define (icadaar x) (icadar (icar x)))
  (define (icadadr x) (icadar (icdr x)))
  (define (icaddar x) (icaddr (icar x)))
  (define (icadddr x) (icaddr (icdr x)))
  (define (icdaaar x) (icdaar (icar x)))
  (define (icdaadr x) (icdaar (icdr x)))
  (define (icdadar x) (icdadr (icar x)))
  (define (icdaddr x) (icdadr (icdr x)))
  (define (icddaar x) (icddar (icar x)))
  (define (icddadr x) (icddar (icdr x)))
  (define (icdddar x) (icdddr (icar x)))
  (define (icddddr x) (icdddr (icdr x)))
  (define ifirst icar)
  (define isecond icadr)
  (define ithird icaddr)
  (define ifourth icadddr)
  (define (ififth x) (icar (icddddr x)))
  (define (isixth x) (icadr (icddddr x)))
  (define (iseventh x) (icaddr (icddddr x)))
  (define (ieighth x) (icadddr (icddddr x)))
  (define (ininth x) (icar (icddddr (icddddr x))))
  (define (itenth x) (icadr (icddddr (icddddr x))))
  (define (icar+icdr ipair)
    (values (icar ipair) (icdr ipair)))
  (define (itake lis k)
    (check-arg integer? k itake)
    (let recur ([lis lis] [k k])
      (if (zero? k)
          '()
          (ipair (icar lis) (recur (icdr lis) (- k 1))))))
  (define (ilist-tail lis k) (idrop lis k))
  (define (idrop lis k)
    (check-arg integer? k idrop)
    (let iter ([lis lis] [k k])
      (if (zero? k) lis (iter (icdr lis) (- k 1)))))
  (define (itake-right lis k)
    (check-arg integer? k itake-right)
    (let lp ([lag lis] [lead (idrop lis k)])
      (if (ipair? lead) (lp (icdr lag) (icdr lead)) lag)))
  (define (idrop-right lis k)
    (check-arg integer? k idrop-right)
    (let recur ([lag lis] [lead (idrop lis k)])
      (if (ipair? lead)
          (ipair (icar lag) (recur (icdr lag) (icdr lead)))
          '())))
  (define (ilist-ref lis i) (icar (idrop lis i)))
  (define (isplit-at x k)
    (check-arg integer? k isplit-at)
    (let recur ([lis x] [k k])
      (if (zero? k)
          (values '() lis)
          (receive
            (prefix suffix)
            (recur (icdr lis) (- k 1))
            (values (ipair (icar lis) prefix) suffix)))))
  (define (ilast lis) (icar (last-ipair lis)))
  (define (last-ipair lis)
    (check-arg ipair? lis last-ipair)
    (let lp ([lis lis])
      (let ([tail (icdr lis)]) (if (ipair? tail) (lp tail) lis))))
  (define (iunzip1 lis) (imap icar lis))
  (define (iunzip2 lis)
    (let recur ([lis lis])
      (if (null-ilist? lis)
          (values lis lis)
          (let ([elt (icar lis)])
            (receive
              (a b)
              (recur (icdr lis))
              (values (ipair (icar elt) a) (ipair (icadr elt) b)))))))
  (define (iunzip3 lis)
    (let recur ([lis lis])
      (if (null-ilist? lis)
          (values lis lis lis)
          (let ([elt (icar lis)])
            (receive
              (a b c)
              (recur (icdr lis))
              (values
                (ipair (icar elt) a)
                (ipair (icadr elt) b)
                (ipair (icaddr elt) c)))))))
  (define (iunzip4 lis)
    (let recur ([lis lis])
      (if (null-ilist? lis)
          (values lis lis lis lis)
          (let ([elt (icar lis)])
            (receive
              (a b c d)
              (recur (icdr lis))
              (values
                (ipair (icar elt) a)
                (ipair (icadr elt) b)
                (ipair (icaddr elt) c)
                (ipair (icadddr elt) d)))))))
  (define (iunzip5 lis)
    (let recur ([lis lis])
      (if (null-ilist? lis)
          (values lis lis lis lis lis)
          (let ([elt (icar lis)])
            (receive
              (a b c d e)
              (recur (icdr lis))
              (values (ipair (icar elt) a) (ipair (icadr elt) b)
                (ipair (icaddr elt) c) (ipair (icadddr elt) d)
                (ipair (icar (icddddr elt)) e)))))))
  (define (iappend . lists)
    (if (pair? lists)
        (let recur ([list1 (car lists)] [lists (cdr lists)])
          (if (pair? lists)
              (let ([tail (recur (car lists) (cdr lists))])
                (ifold-right ipair tail list1))
              list1))
        '()))
  (define (iappend-reverse rev-head tail)
    (let lp ([rev-head rev-head] [tail tail])
      (if (null-ilist? rev-head)
          tail
          (lp (icdr rev-head) (ipair (icar rev-head) tail)))))
  (define (iconcatenate lists)
    (ireduce-right iappend '() lists))
  (define (%cdrs lists)
    (call-with-current-continuation
      (lambda (abort)
        (let recur ([lists lists])
          (if (pair? lists)
              (let ([lis (car lists)])
                (if (null? lis)
                    (abort '())
                    (cons (icdr lis) (recur (cdr lists)))))
              '())))))
  (define (%cars+ lists last-elt)
    (let recur ([lists lists])
      (if (pair? lists)
          (cons (icar (car lists)) (recur (cdr lists)))
          (list last-elt))))
  (define (%cars+cdrs ilists)
    (call-with-current-continuation
      (lambda (abort)
        (let recur ([ilists ilists])
          (if (pair? ilists)
              (let ([ilist (car ilists)] [other-ilists (cdr ilists)])
                (if (null? ilist)
                    (abort '() '())
                    (let ([a (icar ilist)] [d (icdr ilist)])
                      (receive
                        (icars icdrs)
                        (recur other-ilists)
                        (values (cons a icars) (cons d icdrs))))))
              (values '() '()))))))
  (define (%cars+cdrs+ ilists cars-final)
    (call-with-current-continuation
      (lambda (abort)
        (let recur ([ilists ilists])
          (if (pair? ilists)
              (let ([ilist (car ilists)] [other-ilists (cdr ilists)])
                (if (null? ilist)
                    (abort '() '())
                    (receive
                      (a d)
                      (icar+icdr ilist)
                      (receive
                        (cars cdrs)
                        (recur other-ilists)
                        (values (cons a cars) (cons d cdrs))))))
              (values (list cars-final) '()))))))
  (define (%cars+cdrs/no-test ilists)
    (let recur ([ilists ilists])
      (if (pair? ilists)
          (let ([ilist (car ilists)] [other-ilists (cdr ilists)])
            (let ([a (icar ilist)] [d (icdr ilist)])
              (receive
                (cars cdrs)
                (recur other-ilists)
                (values (cons a cars) (cons d cdrs)))))
          (values '() '()))))
  (define (icount pred ilist1 . ilists)
    (check-arg procedure? pred icount)
    (if (pair? ilists)
        (let lp ([ilist1 ilist1] [ilists ilists] [i 0])
          (if (null-ilist? ilist1)
              i
              (receive
                (as ds)
                (%cars+cdrs ilists)
                (if (null? as)
                    i
                    (lp (icdr ilist1)
                        ds
                        (if (apply pred (icar ilist1) as) (+ i 1) i))))))
        (let lp ([lis ilist1] [i 0])
          (if (null-ilist? lis)
              i
              (lp (icdr lis) (if (pred (icar lis)) (+ i 1) i))))))
  (define (iunfold-right p f g seed . maybe-tail)
    (check-arg procedure? p iunfold-right)
    (check-arg procedure? f iunfold-right)
    (check-arg procedure? g iunfold-right)
    (let lp ([seed seed] [ans (:optional maybe-tail '())])
      (if (p seed) ans (lp (g seed) (ipair (f seed) ans)))))
  (define (iunfold p f g seed . maybe-tail-gen)
    (check-arg procedure? p iunfold)
    (check-arg procedure? f iunfold)
    (check-arg procedure? g iunfold)
    (if (pair? maybe-tail-gen)
        (let ([tail-gen (car maybe-tail-gen)])
          (if (pair? (cdr maybe-tail-gen))
              (apply error* "Too many arguments" iunfold p f g seed
                maybe-tail-gen)
              (let recur ([seed seed])
                (if (p seed)
                    (tail-gen seed)
                    (ipair (f seed) (recur (g seed)))))))
        (let recur ([seed seed])
          (if (p seed) '() (ipair (f seed) (recur (g seed)))))))
  (define (ifold kons knil ilis1 . ilists)
    (check-arg procedure? kons ifold)
    (if (pair? ilists)
        (let lp ([ilists (cons ilis1 ilists)] [ans knil])
          (receive
            (cars+ans cdrs)
            (%cars+cdrs+ ilists ans)
            (if (null? cars+ans) ans (lp cdrs (apply kons cars+ans)))))
        (let lp ([ilis ilis1] [ans knil])
          (if (null-ilist? ilis)
              ans
              (lp (icdr ilis) (kons (icar ilis) ans))))))
  (define (ifold-right kons knil ilis1 . ilists)
    (check-arg procedure? kons ifold-right)
    (if (pair? ilists)
        (let recur ([ilists (cons ilis1 ilists)])
          (let ([cdrs (%cdrs ilists)])
            (if (null? cdrs)
                knil
                (apply kons (%cars+ ilists (recur cdrs))))))
        (let recur ([ilis ilis1])
          (if (null? ilis)
              knil
              (let ([head (icar ilis)])
                (kons head (recur (icdr ilis))))))))
  (define (ipair-fold-right f zero ilis1 . ilists)
    (check-arg procedure? f ipair-fold-right)
    (if (pair? ilists)
        (let recur ([ilists (cons ilis1 ilists)])
          (let ([cdrs (%cdrs ilists)])
            (if (null? cdrs)
                zero
                (apply f (append ilists (list (recur cdrs)))))))
        (let recur ([ilis ilis1])
          (if (null-ilist? ilis) zero (f ilis (recur (icdr ilis)))))))
  (define (ipair-fold f zero ilis1 . ilists)
    (check-arg procedure? f ipair-fold)
    (if (pair? ilists)
        (let lp ([ilists (cons ilis1 ilists)] [ans zero])
          (let ([tails (%cdrs ilists)])
            (if (null? tails)
                ans
                (lp tails (apply f (append ilists (list ans)))))))
        (let lp ([ilis ilis1] [ans zero])
          (if (null-ilist? ilis)
              ans
              (let ([tail (icdr ilis)]) (lp tail (f ilis ans)))))))
  (define (ireduce f ridentity ilis)
    (check-arg procedure? f ireduce)
    (if (null-ilist? ilis)
        ridentity
        (ifold f (icar ilis) (icdr ilis))))
  (define (ireduce-right f ridentity ilis)
    (check-arg procedure? f ireduce-right)
    (if (null-ilist? ilis)
        ridentity
        (let recur ([head (icar ilis)] [ilis (icdr ilis)])
          (if (ipair? ilis)
              (f head (recur (icar ilis) (icdr ilis)))
              head))))
  (define (iappend-map f ilis1 . ilists)
    (really-iappend-map iappend-map iappend f ilis1 ilists))
  (define (really-iappend-map who appender f ilis1 ilists)
    (check-arg procedure? f who)
    (if (pair? ilists)
        (receive
          (cars cdrs)
          (%cars+cdrs (cons ilis1 ilists))
          (if (null? cars)
              '()
              (let recur ([cars cars] [cdrs cdrs])
                (let ([vals (apply f cars)])
                  (receive
                    (cars2 cdrs2)
                    (%cars+cdrs cdrs)
                    (if (null? cars2)
                        vals
                        (appender vals (recur cars2 cdrs2))))))))
        (if (null-ilist? ilis1)
            '()
            (let recur ([elt (icar ilis1)] [rest (icdr ilis1)])
              (let ([vals (f elt)])
                (if (null-ilist? rest)
                    vals
                    (appender vals (recur (icar rest) (icdr rest)))))))))
  (define (ipair-for-each proc ilis1 . ilists)
    (check-arg procedure? proc ipair-for-each)
    (if (pair? ilists)
        (let lp ([ilists (cons ilis1 ilists)])
          (let ([itails (%cdrs ilists)])
            (if (pair? itails)
                (begin (apply proc ilists) (lp itails)))))
        (let lp ([ilis ilis1])
          (if (not (null-ilist? ilis))
              (let ([tail (icdr ilis)]) (proc ilis) (lp tail))))))
  (define (ifilter-map f ilis1 . ilists)
    (check-arg procedure? f ifilter-map)
    (if (pair? ilists)
        (let recur ([ilists (cons ilis1 ilists)])
          (receive
            (cars cdrs)
            (%cars+cdrs ilists)
            (if (pair? cars)
                (cond
                  [(apply f cars) => (lambda (x) (ipair x (recur cdrs)))]
                  [else (recur cdrs)])
                '())))
        (let recur ([ilis ilis1])
          (if (null-ilist? ilis)
              ilis
              (let ([tail (recur (icdr ilis))])
                (cond
                  [(f (icar ilis)) => (lambda (x) (ipair x tail))]
                  [else tail]))))))
  (define (imap-in-order f lis1 . lists)
    (check-arg procedure? f imap-in-order)
    (if (pair? lists)
        (let recur ([lists (cons lis1 lists)])
          (receive
            (cars cdrs)
            (%cars+cdrs lists)
            (if (pair? cars)
                (let ([x (apply f cars)]) (ipair x (recur cdrs)))
                '())))
        (let recur ([lis lis1])
          (if (null-ilist? lis)
              lis
              (let ([tail (icdr lis)] [x (f (icar lis))])
                (ipair x (recur tail)))))))
  (define imap imap-in-order)
  (define (ifilter pred lis)
    (check-arg procedure? pred ifilter)
    (let recur ([lis lis])
      (if (null-ilist? lis)
          lis
          (let ([head (icar lis)] [tail (icdr lis)])
            (if (pred head)
                (let ([new-tail (recur tail)])
                  (if (eq? tail new-tail) lis (ipair head new-tail)))
                (recur tail))))))
  (define (ipartition pred lis)
    (check-arg procedure? pred ipartition)
    (let recur ([lis lis])
      (if (null-ilist? lis)
          (values lis lis)
          (let ([elt (icar lis)] [tail (icdr lis)])
            (receive
              (in out)
              (recur tail)
              (if (pred elt)
                  (values (if (ipair? out) (ipair elt in) lis) out)
                  (values in (if (ipair? in) (ipair elt out) lis))))))))
  (define (iremove pred l)
    (ifilter (lambda (x) (not (pred x))) l))
  (define (idelete x lis . maybe-=)
    (let ([= (:optional maybe-= equal?)])
      (ifilter (lambda (y) (not (= x y))) lis)))
  (define (imember x lis . maybe-=)
    (let ([= (:optional maybe-= equal?)])
      (ifind-tail (lambda (y) (= x y)) lis)))
  (define (imemq x lis) (imember x lis eq?))
  (define (imemv x lis) (imember x lis eqv?))
  (define (idelete-duplicates lis . maybe-=)
    (let ([elt= (:optional maybe-= equal?)])
      (check-arg procedure? elt= idelete-duplicates)
      (let recur ([lis lis])
        (if (null-ilist? lis)
            lis
            (let* ([x (icar lis)]
                   [tail (icdr lis)]
                   [new-tail (recur (idelete x tail elt=))])
              (if (eq? tail new-tail) lis (ipair x new-tail)))))))
  (define (iassoc x lis . maybe-=)
    (let ([= (:optional maybe-= equal?)])
      (ifind (lambda (entry) (= x (icar entry))) lis)))
  (define (ialist-cons key datum alist)
    (ipair (ipair key datum) alist))
  (define (alist-copy alist)
    (imap (lambda (elt) (ipair (icar elt) (icdr elt))) alist))
  (define (ialist-delete key alist . maybe-=)
    (let ([= (:optional maybe-= equal?)])
      (ifilter (lambda (elt) (not (= key (icar elt)))) alist)))
  (define (ifind pred ilist)
    (cond [(ifind-tail pred ilist) => icar] [else #f]))
  (define (ifind-tail pred ilist)
    (check-arg procedure? pred ifind-tail)
    (let lp ([ilist ilist])
      (and (not (null-ilist? ilist))
           (if (pred (icar ilist)) ilist (lp (icdr ilist))))))
  (define (itake-while pred lis)
    (check-arg procedure? pred itake-while)
    (let recur ([lis lis])
      (if (null-ilist? lis)
          '()
          (let ([x (icar lis)])
            (if (pred x) (ipair x (recur (icdr lis))) '())))))
  (define (idrop-while pred lis)
    (check-arg procedure? pred idrop-while)
    (let lp ([lis lis])
      (if (null-ilist? lis)
          '()
          (if (pred (icar lis)) (lp (icdr lis)) lis))))
  (define (ispan pred lis)
    (check-arg procedure? pred ispan)
    (let recur ([lis lis])
      (if (null-ilist? lis)
          (values '() '())
          (let ([x (icar lis)])
            (if (pred x)
                (receive
                  (prefix suffix)
                  (recur (icdr lis))
                  (values (ipair x prefix) suffix))
                (values '() lis))))))
  (define (ibreak pred lis)
    (ispan (lambda (x) (not (pred x))) lis))
  (define (ievery pred lis1 . lists)
    (check-arg procedure? pred ievery)
    (if (pair? lists)
        (receive
          (heads tails)
          (%cars+cdrs (ipair lis1 lists))
          (or (not (ipair? heads))
              (let lp ([heads heads] [tails tails])
                (receive
                  (next-heads next-tails)
                  (%cars+cdrs tails)
                  (if (ipair? next-heads)
                      (and (apply pred heads) (lp next-heads next-tails))
                      (apply pred heads))))))
        (or (null-ilist? lis1)
            (let lp ([head (icar lis1)] [tail (icdr lis1)])
              (if (null-ilist? tail)
                  (pred head)
                  (and (pred head) (lp (icar tail) (icdr tail))))))))
  (define (iany pred ilis1 . ilists)
    (check-arg procedure? pred iany)
    (if (pair? ilists)
        (receive
          (heads tails)
          (%cars+cdrs (cons ilis1 ilists))
          (and (pair? heads)
               (let lp ([heads heads] [tails tails])
                 (receive
                   (next-heads next-tails)
                   (%cars+cdrs tails)
                   (if (pair? next-heads)
                       (or (apply pred heads) (lp next-heads next-tails))
                       (apply pred heads))))))
        (and (not (null-ilist? ilis1))
             (let lp ([head (icar ilis1)] [tail (icdr ilis1)])
               (if (null-ilist? tail)
                   (pred head)
                   (or (pred head) (lp (icar tail) (icdr tail))))))))
  (define (ilist-index pred lis1 . lists)
    (check-arg procedure? pred ilist-index)
    (if (pair? lists)
        (let lp ([lists (cons lis1 lists)] [n 0])
          (receive
            (heads tails)
            (%cars+cdrs lists)
            (and (pair? heads)
                 (if (apply pred heads) n (lp tails (+ n 1))))))
        (let lp ([lis lis1] [n 0])
          (and (not (null-ilist? lis))
               (if (pred (icar lis)) n (lp (icdr lis) (+ n 1)))))))
  (define (ireverse lis) (ifold ipair '() lis)))
