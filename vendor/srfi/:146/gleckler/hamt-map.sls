;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: %3a146/gleckler/hamt-map.sls
;;;; Persistent Hash Map
(library (srfi :146 gleckler hamt-map)
  (export make-phm phm? phm->alist phm/add-alist phm/add-alist!
   phm/contains? phm/count phm/empty? phm/for-each phm/get
   phm/immutable phm/keys phm/mutable phm/mutable? phm/put
   phm/put! phm/remove phm/remove! phm/replace phm/replace!
   phm/data)
  (import (except (rnrs) assert) (only (srfi :1) fold) (srfi :16)
    (srfi :146 gleckler hamt) (srfi :146 gleckler hamt-misc))
  (define (phm? datum)
    (and (hash-array-mapped-trie? datum) (hamt/payload? datum)))
  (define (make-phm-inner hash = alist)
    (let ([phm (make-hamt = hash #t)])
      (if (null? alist)
          phm
          (let ([phm-1 (phm/mutable phm)])
            (phm/add-alist! phm-1 alist)
            (phm/immutable phm-1)))))
  (define make-phm
    (case-lambda
      [(hash =) (make-phm-inner hash = '())]
      [(hash = alist) (make-phm-inner hash = alist)]))
  (define (phm/count phm)
    (assert (phm? phm))
    (hamt/count phm))
  (define (phm/empty? phm)
    (assert (phm? phm))
    (hamt/empty? phm))
  (define phm/immutable
    (case-lambda
      [(phm) (assert (phm? phm)) (hamt/immutable phm)]
      [(phm replace)
       (assert (phm? phm))
       (hamt/immutable phm replace)]))
  (define (phm/mutable phm)
    (assert (phm? phm))
    (hamt/mutable phm))
  (define (phm/mutable? phm)
    (assert (phm? phm))
    (hamt/mutable? phm))
  (define (phm/put phm key datum)
    (assert (phm? phm))
    (hamt/put phm key datum))
  (define (phm/put! phm key datum)
    (assert (phm? phm))
    (hamt/put! phm key datum))
  (define (phm/replace phm key replace)
    (assert (phm? phm))
    (hamt/replace phm key replace))
  (define (phm/replace! phm key replace)
    (assert (phm? phm))
    (hamt/replace! phm key replace))
  (define (phm/get-inner phm key default)
    (assert (phm? phm))
    (let ([result (hamt-fetch phm key)])
      (if (hamt-null? result) default result)))
  (define phm/get
    (case-lambda
      [(phm key) (phm/get-inner phm key #f)]
      [(phm key default) (phm/get-inner phm key default)]))
  (define (phm/contains? phm key)
    (assert (phm? phm))
    (not (hamt-null? (hamt-fetch phm key))))
  (define (phm/remove phm key)
    (assert (phm? phm))
    (phm/put phm key hamt-null))
  (define (phm/remove! phm key)
    (assert (phm? phm))
    (assert (hamt/mutable? phm))
    (phm/put! phm key hamt-null))
  (define (phm/add-alist phm alist)
    (assert (phm? phm))
    (fold
      (lambda (a phm) (phm/put phm (car a) (cdr a)))
      phm
      alist))
  (define (phm/add-alist! phm alist)
    (assert (phm? phm))
    (do-list (a alist) (phm/put! phm (car a) (cdr a)))
    phm)
  (define (phm->alist phm)
    (assert (phm? phm))
    (hamt->list phm cons))
  (define (phm/data phm)
    (assert (phm? phm))
    (hamt->list phm (lambda (k d) d)))
  (define (phm/keys phm)
    (assert (phm? phm))
    (hamt->list phm (lambda (k d) k)))
  (define (phm/for-each procedure phm)
    (assert (phm? phm))
    (hamt/for-each procedure phm)))
