;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: %3a25/multi-dimensional-arrays/arlib.sls
#!r6rs
;; Copyright 2009 Derick Eddington.  My MIT-style license is in the file named
;; LICENSE from the original collection this file is distributed with.
;;;;;; File header: %3a25/arlib.scm
;;; array arlib
(library (srfi :25 multi-dimensional-arrays arlib)
  (export array-shape array-length array-size array-equal?
   shape-for-each array-for-each-index tabulate-array
   tabulate-array! array-retabulate! array-map array-map!
   array->vector array->list share-array/prefix share-row
   share-column share-array/origin share-array/index!
   array-append transpose share-nths)
  (import (rnrs) (rnrs r5rs) (srfi :23 error tricks)
    (srfi :25 multi-dimensional-arrays all)
    (srfi private include))
  (SRFI-23-error->R6RS
    "(library (srfi :25 multi-dimensional-arrays arlib))"
    (begin
      (define (array-shape arr)
        (let ([r (array-rank arr)])
          (let ([m (make-array (shape 0 r 0 2))])
            (do ([d 0 (+ d 1)])
                ((= d r) m)
              (array-set! m d 0 (array-start arr d))
              (array-set! m d 1 (array-end arr d))))))
      (define (array-length arr dim)
        (- (array-end arr dim) (array-start arr dim)))
      (define (array-size arr)
        (let ([r (array-rank arr)])
          (do ([k 0 (+ k 1)] [p 1 (* p (array-length arr k))])
              ((= k r) p))))
      (define (array-equal? a b)
        (let ([r (array-rank a)])
          (and (= r (array-rank b))
               (and (do ([k 0 (+ k 1)]
                         [true #t (and true
                                       (= (array-start a k)
                                          (array-start b k))
                                       (= (array-end a k)
                                          (array-end b k)))])
                        ((= k r) true))
                    (let ([ks (make-vector r 0)])
                      (let wok ([d 0])
                        (if (< d r)
                            (let ([e (array-end a d)])
                              (do ([k (array-start a d) (+ k 1)]
                                   [true #t (and true (wok (+ d 1)))])
                                  ((= k e) true)
                                (vector-set! ks d k)))
                            (equal?
                              (array-ref a ks)
                              (array-ref b ks)))))))))
      (define (shape-for-each shp proc . o)
        (if (null? o)
            (array:arlib:shape-for-each/arguments shp proc)
            (if (vector? (car o))
                (array:arlib:shape-for-each/vector shp proc (car o))
                (array:arlib:shape-for-each/array shp proc (car o)))))
      (define (array:arlib:shape-for-each/arguments shp proc)
        (let ([r (array-end shp 0)])
          (let ([vec (make-vector r)])
            (let do-dim ([d 0])
              (if (= d r)
                  (array:apply-to-vector r proc vec)
                  (let ([e (array-ref shp d 1)])
                    (do ([k (array-ref shp d 0) (+ k 1)])
                        ((= k e))
                      (vector-set! vec d k)
                      (do-dim (+ d 1)))))))))
      (define (array:arlib:shape-for-each/vector shp proc vec)
        (let ([r (array-end shp 0)])
          (let do-dim ([d 0])
            (if (= d r)
                (proc vec)
                (let ([e (array-ref shp d 1)])
                  (do ([k (array-ref shp d 0) (+ k 1)])
                      ((= k e))
                    (vector-set! vec d k)
                    (do-dim (+ d 1))))))))
      (define (array:arlib:shape-for-each/array shp proc arr)
        (let ([r (array-end shp 0)])
          (let do-dim ([d 0])
            (if (= d r)
                (proc arr)
                (let ([e (array-ref shp d 1)])
                  (do ([k (array-ref shp d 0) (+ k 1)])
                      ((= k e))
                    (array-set! arr d k)
                    (do-dim (+ d 1))))))))
      (define (array-for-each-index arr proc . o)
        (if (null? o)
            (array:arlib:array-for-each-index/arguments arr proc)
            (if (vector? (car o))
                (array:arlib:array-for-each-index/vector arr proc (car o))
                (array:arlib:array-for-each-index/array
                  arr
                  proc
                  (car o)))))
      (define (array:arlib:array-for-each-index/arguments arr
               proc)
        (let ([r (array-rank arr)])
          (let ([vec (make-vector r)]
                [apply (array:applier-to-vector r)])
            (let do-dim ([d 0])
              (if (= d r)
                  (apply proc vec)
                  (let ([e (array-end arr d)])
                    (do ([k (array-start arr d) (+ k 1)])
                        ((= k e))
                      (vector-set! vec d k)
                      (do-dim (+ d 1)))))))))
      (define (array:arlib:array-for-each-index/vector arr proc
               ind)
        (let ([r (array-rank arr)])
          (let do-dim ([d 0])
            (if (= d r)
                (proc ind)
                (let ([e (array-end arr d)])
                  (do ([k (array-start arr d) (+ k 1)])
                      ((= k e))
                    (vector-set! ind d k)
                    (do-dim (+ d 1))))))))
      (define (array:arlib:array-for-each-index/array arr proc
               ind)
        (let ([r (array-rank arr)])
          (let do-dim ([d 0])
            (if (= d r)
                (proc ind)
                (let ([e (array-end arr d)])
                  (do ([k (array-start arr d) (+ k 1)])
                      ((= k e))
                    (array-set! ind d k)
                    (do-dim (+ d 1))))))))
      (define (tabulate-array shp proc)
        (let ([arr (make-array shp)])
          (array:arlib:shape-for-each/vector
            shp
            (let ([apply (array:applier-to-vector (array-end shp 0))])
              (lambda (ix) (array-set! arr ix (apply proc ix))))
            (make-vector (array-end shp 0)))
          arr))
      (define (tabulate-array! shp proc ind)
        (let ([arr (make-array shp)])
          (if (vector? ind)
              (array:arlib:shape-for-each/vector
                shp
                (lambda (ix) (array-set! arr ix (proc ix)))
                ind)
              (array:arlib:shape-for-each/array
                shp
                (lambda (ix) (array-set! arr ix (proc ix)))
                ind))
          arr))
      (define (array-retabulate! arr shp proc . o)
        (if (null? o)
            (array:arlib:shape-for-each/vector
              shp
              (let ([apply (array:applier-to-vector (array-end shp 0))])
                (lambda (ix) (array-set! arr ix (apply proc ix))))
              (make-vector (array-end shp 0)))
            (if (vector? (car o))
                (array:arlib:shape-for-each/vector
                  shp
                  (lambda (ix) (array-set! arr ix (proc ix)))
                  (car o))
                (array:arlib:shape-for-each/array
                  shp
                  (lambda (ix) (array-set! arr ix (proc ix)))
                  (car o)))))
      (define (array-map! arr x y . o)
        (if (array:array? x)
            (array:arlib:map! arr x y (apply vector o))
            (array:arlib:map!
              arr
              (array-shape arr)
              x
              (apply vector y o))))
      (define (array:arlib:map! arr shp proc args)
        (let ([rank (vector-length args)])
          (let ([argv (make-vector rank)])
            (array:arlib:shape-for-each/vector
              shp
              (let ([apply (array:applier-to-vector rank)])
                (lambda (ix)
                  (do ([k 0 (+ k 1)])
                      ((= k rank))
                    (vector-set!
                      argv
                      k
                      (array-ref (vector-ref args k) ix)))
                  (array-set! arr ix (apply proc argv))))
              (make-vector (array-end shp 0))))))
      (define (array-map x y . o)
        (if (array:array? x)
            (let ([arr (make-array x)])
              (array:arlib:map! arr x y (apply vector o))
              arr)
            (let ([shp (array-shape y)])
              (let ([arr (make-array shp)])
                (array:arlib:map! arr shp x (apply vector y o))
                arr))))
      (define (array->vector arr)
        (let ([vec (make-vector (array-size arr))])
          (let ([k 0])
            (shape-for-each
              (array-shape arr)
              (lambda (index)
                (vector-set! vec k (array-ref arr index))
                (set! k (+ k 1)))
              (make-vector (array-rank arr)))
            vec)))
      (define (array->list arr)
        (vector->list (array->vector arr)))
      (define (share-row arr k)
        (share-array
          arr
          (let ([bounds (array->list (array-shape arr))])
            (apply shape (cddr bounds)))
          (lambda ks (apply values k ks))))
      (define (share-array/prefix arr . js)
        (if (or (null? js) (integer? (car js)))
            (share-array
              arr
              (let ([bounds (array->list (array-shape arr))])
                (apply shape (list-tail bounds (* 2 (length js)))))
              (lambda ks (apply values (append js ks))))
            (apply
              (lambda (fix)
                (share-array/prefix!
                  arr
                  fix
                  (make-vector
                    (- (array-rank arr)
                       (if (vector? fix)
                           (vector-length fix)
                           (array-end fix 0))))))
              js)))
      (define (share-array/prefix! arr fix in . out)
        (let* ([out (if (pair? out)
                        ((lambda (out) out) out)
                        (make-vector (array-rank arr)))]
               [fix-ref (if (vector? fix) vector-ref array-ref)]
               [in-ref (if (vector? in) vector-ref array-ref)]
               [out-set! (if (vector? out) vector-set! array-set!)]
               [m (if (vector? fix) (vector-length fix) (array-end fix 0))]
               [n (if (vector? out)
                      (vector-length out)
                      (array-end out 0))])
          (do ([k 0 (+ k 1)])
              ((= k m))
            (out-set! out k (fix-ref fix k)))
          (share-array/index!
            arr
            (let ([bounds (array->list (array-shape arr))])
              (apply
                shape
                (list-tail
                  bounds
                  (if (vector? fix)
                      (* 2 (vector-length fix))
                      (* 2 (array-end fix 0))))))
            (lambda (in)
              (do ([k m (+ k 1)])
                  ((= k n))
                (out-set! out k (in-ref in (- k m))))
              out)
            in)))
      (define (share-column arr k)
        (share-array
          arr
          (let ([bounds (array->list (array-shape arr))])
            (apply shape (car bounds) (cadr bounds) (cddddr bounds)))
          (lambda ks (apply values (car ks) k (cdr ks)))))
      (define (share-array/origin arr . xs)
        (let ([new (if (or (null? xs) (integer? (car xs)))
                       xs
                       (apply
                         (lambda (x)
                           (if (vector? x)
                               (vector->list x)
                               (if (array? x)
                                   (array->list x)
                                   (error "share-array/origin: bad thing"))))
                         xs))])
          (do ([k (array-rank arr) (- k 1)]
               [old '() (cons (array-start arr (- k 1)) old)])
              ((= k 0)
               (let ([ds (map - new old)])
                 (share-array
                   arr
                   (tabulate-array
                     (shape 0 (array-rank arr) 0 2)
                     (lambda (r k)
                       (case k
                         [(0) (+ (array-start arr r) (list-ref ds r))]
                         [(1) (+ (array-end arr r) (list-ref ds r))])))
                   (lambda ks (apply values (map - ks ds)))))))))
      (define (array-append dim arr . ars)
        (let* ([total (do ([m (array-length arr dim) (+ m
                                                        (array-length
                                                          (car r)
                                                          dim))]
                           [r ars (cdr r)])
                          ((null? r) m))]
               [common (array-shape arr)]
               [origin (array->vector (share-column common 0))]
               [index (make-vector (array-rank arr))])
          (array-set! common dim 1 (+ (array-start arr dim) total))
          (let ([result (make-array common)])
            (array-set! common dim 1 (array-start arr dim))
            (let wok ([arr arr] [ars ars])
              (vector-set! origin dim (array-ref common dim 1))
              (let ([arr1 (share-array/origin arr origin)])
                (array-set! common dim 0 (array-start arr1 dim))
                (array-set! common dim 1 (array-end arr1 dim))
                (shape-for-each
                  common
                  (lambda (index)
                    (array-set! result index (array-ref arr1 index)))
                  index))
              (if (pair? ars) (wok (car ars) (cdr ars))))
            result)))
      (define (array:arlib:matrix-times a b)
        (or (and (= (array-rank a) 2) (= (array-rank b) 2))
            (error "times: arrays are not matrices"))
        (let ([r0 (array-start a 0)]
              [rn (array-end a 0)]
              [t0 (array-start a 1)]
              [tn (array-end a 1)]
              [u0 (array-start b 0)]
              [un (array-end b 0)]
              [k0 (array-start b 1)]
              [kn (array-end b 1)])
          (or (= (- tn t0) (- un u0))
              (error "times: matrices are not compatible"))
          (let ([ab (make-array (shape r0 rn k0 kn))])
            (do ([r r0 (+ r 1)])
                ((= r rn))
              (do ([k k0 (+ k 1)])
                  ((= k kn))
                (do ([t t0 (+ t 1)]
                     [u u0 (+ u 1)]
                     [s 0 (+ s (* (array-ref a r t) (array-ref b u k)))])
                    ((and (= t tn) (= u un)) (array-set! ab r k s)))))
            ab)))
      (define (array:arlib:permutation-matrix . ds)
        (let* ([n (length ds)] [arr (make-array (shape 0 n 0 n) 0)])
          (do ([k 0 (+ k 1)] [ds ds (cdr ds)])
              ((= k n))
            (array-set! arr k (car ds) 1))
          arr))
      (define (transpose a . p0)
        (let* ([r (array-rank a)]
               [permutation (apply
                              array:arlib:permutation-matrix
                              (if (pair? p0)
                                  p0
                                  (do ([ds '() (cons d ds)] [d 0 (+ d 1)])
                                      ((= d r) ds))))]
               [inverse-permutation (share-array
                                      permutation
                                      (array-shape permutation)
                                      (lambda (r k) (values k r)))])
          (share-array
            a
            (array:arlib:matrix-times permutation (array-shape a))
            (lambda ks0
              (apply
                values
                (array->list
                  (array:arlib:matrix-times
                    inverse-permutation
                    (apply array (shape 0 r 0 1) ks0))))))))
      (define (share-array/index! array subshape proc index)
        (array:share/index! array subshape proc index))
      (define (share-nths arr d n)
        (let* ([bounds (array->vector (array-shape arr))]
               [b (vector-ref bounds (* 2 d))]
               [e (vector-ref bounds (+ (* 2 d) 1))])
          (vector-set!
            bounds
            (+ (* 2 d) 1)
            (+ b (quotient (+ n (- e b 1)) n)))
          (share-array
            arr
            (apply shape (vector->list bounds))
            (lambda ks
              (apply
                values
                (let d/nk ([u 0] [ks ks])
                  (if (= u d)
                      (cons (+ b (* n (- (car ks) b))) (cdr ks))
                      (cons (car ks) (d/nk (+ u 1) (cdr ks)))))))))))))
