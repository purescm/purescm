;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor/
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: %3a214/impl.sls
#!r6rs
(library (purs runtime srfi :214 impl)
  (export make-flexvector flexvector flexvector-unfold
   flexvector-unfold-right flexvector-copy
   flexvector-reverse-copy flexvector-append
   flexvector-concatenate flexvector-append-subvectors
   flexvector? flexvector-empty? flexvector=? flexvector-ref
   flexvector-front flexvector-back flexvector-length
   flexvector-add! flexvector-add-front! flexvector-add-back!
   flexvector-remove! flexvector-remove-front!
   flexvector-remove-back! flexvector-add-all!
   flexvector-remove-range! flexvector-clear! flexvector-set!
   flexvector-swap! flexvector-fill! flexvector-reverse!
   flexvector-copy! flexvector-reverse-copy! flexvector-append!
   flexvector-fold flexvector-fold-right flexvector-map
   flexvector-map! flexvector-map/index flexvector-map/index!
   flexvector-append-map flexvector-append-map/index
   flexvector-filter flexvector-filter! flexvector-filter/index
   flexvector-filter/index! flexvector-for-each
   flexvector-for-each/index flexvector-count
   flexvector-cumulate flexvector-index flexvector-index-right
   flexvector-skip flexvector-skip-right
   flexvector-binary-search flexvector-any flexvector-every
   flexvector-partition flexvector->vector flexvector->list
   flexvector->string vector->flexvector list->flexvector
   string->flexvector reverse-flexvector->list
   reverse-list->flexvector generator->flexvector
   flexvector->generator)
  (import (except (rnrs) vector-fill!) (purs runtime srfi :26)
    (purs runtime srfi :214 parameters)
    (except (purs runtime srfi :133 vectors) vector->list list->vector)
    (purs runtime srfi :158))
  (define (nonnegative? num) (and (number? num) (>= num 0)))
  (define (negate pred?)
    (lambda args (not (apply pred? args))))
  (define (assert-index-validity fv . ids)
    (let ([len (flexvector-len fv)])
      (for-each
        (lambda (i) (assert (and (>= i 0) (< i len))))
        ids)))
  (define (group lst num)
    (define (split l n)
      (let loop ([acc (list)] [ls l] [count 0])
        (cond
          [(>= count n) (values (reverse acc) ls)]
          [(null? ls)
           (error group "Not enough elements for a group" lst num)]
          [else (loop (cons (car ls) acc) (cdr ls) (+ count 1))])))
    (assert (positive? num))
    (let loop ([acc (list)] [source lst])
      (cond
        [(null? source) (reverse acc)]
        [else
         (let-values ([(grp rest) (split source num)])
           (loop (cons grp acc) rest))])))
  (define-record-type (%flexvector
                        %make-flexvector
                        flexvector?)
    (nongenerative flexvector-vtlmh5fxbj)
    (fields
      (mutable vec flexvector-vec flexvector-vec-set!)
      (mutable len flexvector-len flexvector-len-set!)))
  (define-syntax with-flexvectors
    (syntax-rules ()
      [(_ (((vec len) fv) rest ...) body ...)
       (let* ([fv* fv]
              [vec (flexvector-vec fv*)]
              [len (flexvector-len fv*)])
         (with-flexvectors (rest ...) body ...))]
      [(_ () body ...) (let () body ...)]))
  (define-syntax with-clamped-range
    (syntax-rules ()
      [(_ (fv start end) body ...)
       (let ([start (max 0 start)]
             [end (min end (flexvector-len fv))])
         (assert (<= start end))
         (let () body ...))]))
  (define-syntax define-with-range
    (syntax-rules (of)
      [(_ (name fv ... start (end of what)) body ...)
       (define name
         (case-lambda
           [(fv ...) (name fv ... 0)]
           [(fv ... start) (name fv ... start (flexvector-len what))]
           [(fv ... start end)
            (with-clamped-range (what start end) body ...)]))]))
  (define (shortest-length vecs)
    (apply min (map flexvector-len vecs)))
  (define-syntax with-shortest-length
    (syntax-rules ()
      [(_ ((vecs shortest-len) vecs-expr) body ...)
       (let* ([vecs vecs-expr]
              [shortest-len (shortest-length vecs)])
         body
         ...)]))
  (define (flexvector-cap fv)
    (vector-length (flexvector-vec fv)))
  (define (ensure-capacity! fv required-cap)
    (let ([current-cap (flexvector-cap fv)])
      (unless (>= current-cap required-cap)
        (let* ([vec (flexvector-vec fv)]
               [new-cap ((flexvector-capacity-estimator)
                          current-cap
                          required-cap)]
               [new-vec (make-vector new-cap)])
          (vector-copy! new-vec 0 vec 0 (vector-length vec))
          (flexvector-vec-set! fv new-vec)))))
  (define (ensure-valid-capacity requested-size)
    (assert (and (exact? requested-size) (>= requested-size 0)))
    (max requested-size (flexvector-min-capacity)))
  (define make-flexvector
    (case-lambda
      [(size)
       (assert (nonnegative? size))
       (%make-flexvector
         (make-vector (ensure-valid-capacity size))
         size)]
      [(size fill)
       (assert (nonnegative? size))
       (%make-flexvector
         (make-vector (ensure-valid-capacity size) fill)
         size)]))
  (define (flexvector . els)
    (cond
      [(null? els) (make-flexvector 0)]
      [else (list->flexvector els)]))
  (define (flexvector-unfold pred func gen . seeds)
    (let ([fv (flexvector)])
      (do ([seeds seeds (let-values ([seeds (apply gen seeds)])
                          seeds)])
          ((apply pred seeds) fv)
        (flexvector-add-back! fv (apply func seeds)))))
  (define (flexvector-unfold-right pred func gen . seeds)
    (let ([fv (apply flexvector-unfold pred func gen seeds)])
      (flexvector-reverse! fv)
      fv))
  (define-with-range
    (flexvector-copy fv start (end of fv))
    (with-flexvectors
      (((vec len) fv))
      (let ([result (make-flexvector (- end start))])
        (vector-copy! (flexvector-vec result) 0 vec start end)
        result)))
  (define (flexvector-reverse-copy . args)
    (let ([copy (apply flexvector-copy args)])
      (flexvector-reverse! copy)
      copy))
  (define (flexvector-append fv . rest)
    (flexvector-concatenate (cons fv rest)))
  (define (flexvector-concatenate fvs)
    (let* ([total-len (fold-left + 0 (map flexvector-len fvs))]
           [result (make-flexvector total-len)])
      (let loop ([vecs fvs] [offset 0])
        (cond
          [(null? vecs) result]
          [else
           (let ([current (car vecs)])
             (flexvector-copy! result offset current)
             (loop (cdr vecs) (+ offset (flexvector-len current))))]))))
  (define (flexvector-append-subvectors . args)
    (let* ([triplets (group args 3)]
           [subvecs (map (lambda (triplet)
                           (apply flexvector-copy triplet))
                         triplets)])
      (flexvector-concatenate subvecs)))
  (define (flexvector-empty? fv) (zero? (flexvector-len fv)))
  (define (flexvector=? elt=? . fvs)
    (define (combine result . es) (and result (apply elt=? es)))
    (let ([lens (map flexvector-len fvs)])
      (or (null? fvs)
          (null? (cdr fvs))
          (and (apply = lens)
               (apply flexvector-fold combine #t fvs)))))
  (define (flexvector-ref fv index)
    (with-flexvectors
      (((vec len) fv))
      (assert-index-validity fv index)
      (vector-ref vec index)))
  (define (flexvector-front fv) (flexvector-ref fv 0))
  (define (flexvector-back fv)
    (let ([len (flexvector-len fv)])
      (flexvector-ref fv (- len 1))))
  (define flexvector-length flexvector-len)
  (define (flexvector-add! fv i . els)
    (flexvector-add-all! fv i els))
  (define (flexvector-add-front! fv . els)
    (flexvector-add-all! fv 0 els))
  (define (flexvector-add-back! fv . els)
    (flexvector-add-all! fv (flexvector-len fv) els))
  (define (flexvector-add-all! fv i els)
    (let* ([count (length els)]
           [len (flexvector-len fv)]
           [total-len (+ len count)])
      (ensure-capacity! fv total-len)
      (let ([vec (flexvector-vec fv)])
        (vector-copy! vec (+ i count) vec i len)
        (let loop ([ls els] [offset 0])
          (cond
            [(null? ls) (flexvector-len-set! fv total-len) fv]
            [else
             (let ([el (car ls)])
               (vector-set! vec (+ i offset) el)
               (loop (cdr ls) (+ offset 1)))])))))
  (define (flexvector-append! fv . fvs)
    (let* ([len (flexvector-len fv)]
           [total-len (fold-left + len (map flexvector-len fvs))])
      (ensure-capacity! fv total-len)
      (let ([vec (flexvector-vec fv)])
        (let loop ([fvs fvs] [offset len])
          (cond
            [(null? fvs) (flexvector-len-set! fv total-len) fv]
            [else
             (with-flexvectors
               (((current-vec current-len) (car fvs)))
               (vector-copy! vec offset current-vec 0 current-len)
               (loop (cdr fvs) (+ offset current-len)))])))))
  (define (flexvector-remove! fv i)
    (let ([value (flexvector-ref fv i)])
      (flexvector-remove-range! fv i (+ i 1))
      value))
  (define (flexvector-remove-front! fv)
    (flexvector-remove! fv 0))
  (define (flexvector-remove-back! fv)
    (flexvector-remove! fv (- (flexvector-len fv) 1)))
  (define flexvector-remove-range!
    (case-lambda
      [(fv start)
       (flexvector-remove-range! fv start (flexvector-len fv))]
      [(fv start end)
       (with-flexvectors
         (((vec len) fv))
         (let* ([start (max start 0)]
                [end (min len end)]
                [move-count (- len end)]
                [len-delta (- end start)])
           (assert (<= start end))
           (unless (zero? move-count)
             (vector-copy! vec start vec end (+ end move-count)))
           (flexvector-len-set! fv (- len len-delta))
           fv))]))
  (define (flexvector-clear! fv)
    (flexvector-len-set! fv 0)
    fv)
  (define (flexvector-set! fv i el)
    (assert-index-validity fv i)
    (with-flexvectors
      (((vec len) fv))
      (let* ([val (vector-ref vec i)])
        (vector-set! vec i el)
        val)))
  (define (flexvector-swap! fv i j)
    (assert-index-validity fv i j)
    (with-flexvectors (((vec len) fv)) (vector-swap! vec i j)))
  (define-with-range
    (flexvector-fill! fv fill start (end of fv))
    (with-flexvectors
      (((vec len) fv))
      (let ([start (max 0 start)] [end (min end len)])
        (vector-fill! vec fill start end)
        fv)))
  (define-with-range
    (flexvector-reverse! fv start (end of fv))
    (let* ([len (- end start)]
           [vec (flexvector-vec fv)]
           [half (floor (/ len 2))])
      (do ([index 0 (+ index 1)])
          ((>= index half) fv)
        (let ([jndex (- len index 1)])
          (vector-swap! vec (+ start index) (+ start jndex))))))
  (define-with-range
    (flexvector-copy! to at from start (end of from))
    (let* ([len (flexvector-len to)]
           [delta (- end start)]
           [new-len (+ len delta)])
      (assert (and (>= at 0) (<= at len)))
      (ensure-capacity! to new-len)
      (with-flexvectors
        (((to-vec to-len) to) ((from-vec from-len) from))
        (vector-copy! to-vec at from-vec start end)
        (flexvector-len-set! to (max len (+ at delta)))
        to)))
  (define-with-range
    (flexvector-reverse-copy! to at from start (end of from))
    (flexvector-copy! to at from start end)
    (flexvector-reverse! to at (+ at (- end start))))
  (define (flexvector-fold-impl index-proc reductor initial fv
           . rest)
    (with-shortest-length
      ((vecs shortest-len) (cons fv rest))
      (let loop ([index 0] [state initial])
        (cond
          [(>= index shortest-len) state]
          [else
           (loop
             (+ index 1)
             (apply
               reductor
               state
               (map (cut flexvector-ref <> (index-proc index shortest-len))
                    vecs)))]))))
  (define (flexvector-fold reductor initial fv . rest)
    (define (left-to-right index len) index)
    (apply flexvector-fold-impl left-to-right reductor initial
      fv rest))
  (define (flexvector-fold-right reductor initial fv . rest)
    (define (right-to-left index len) (- len index 1))
    (apply flexvector-fold-impl right-to-left reductor initial
      fv rest))
  (define (flexvector-map/index-into! dst proc fv . rest)
    (with-shortest-length
      ((vecs shortest-len) (cons fv rest))
      (let loop ([index 0])
        (cond
          [(>= index shortest-len) dst]
          [else
           (let ([value (apply
                          proc
                          index
                          (map (cut flexvector-ref <> index) vecs))])
             (flexvector-set! dst index value)
             (loop (+ index 1)))]))))
  (define (flexvector-map/index! proc fv . rest)
    (apply flexvector-map/index-into! fv proc fv rest))
  (define (flexvector-map! proc fv . rest)
    (define (ignore-index . args) (apply proc (cdr args)))
    (apply flexvector-map/index! ignore-index fv rest))
  (define (flexvector-map/index proc fv . rest)
    (with-shortest-length
      ((vecs shortest-len) (cons fv rest))
      (let ([result (make-flexvector shortest-len)])
        (apply flexvector-map/index-into! result proc fv rest))))
  (define (flexvector-map proc fv . rest)
    (define (ignore-index . args) (apply proc (cdr args)))
    (apply flexvector-map/index ignore-index fv rest))
  (define (flexvector-append-map/index proc fv . rest)
    (flexvector-fold
      flexvector-append!
      (flexvector)
      (apply flexvector-map/index proc fv rest)))
  (define (flexvector-append-map proc fv . rest)
    (flexvector-fold
      flexvector-append!
      (flexvector)
      (apply flexvector-map proc fv rest)))
  (define (flexvector-filter/index! pred? fv)
    (with-flexvectors
      (((vec len) fv))
      (let loop ([check-index 0] [fill-index 0])
        (cond
          [(>= check-index len)
           (flexvector-len-set! fv fill-index)
           fv]
          [(pred? check-index (flexvector-ref fv check-index))
           (flexvector-set!
             fv
             fill-index
             (flexvector-ref fv check-index))
           (loop (+ check-index 1) (+ fill-index 1))]
          [else (loop (+ check-index 1) fill-index)]))))
  (define (flexvector-filter! pred? fv)
    (define (ignore-index index value) (pred? value))
    (flexvector-filter/index! ignore-index fv))
  (define (flexvector-filter/index pred? fv)
    (flexvector-filter/index! pred? (flexvector-copy fv)))
  (define (flexvector-filter pred? fv)
    (flexvector-filter! pred? (flexvector-copy fv)))
  (define (flexvector-for-each/index proc fv . rest)
    (with-shortest-length
      ((vecs shortest-len) (cons fv rest))
      (do ([index 0 (+ index 1)])
          ((>= index shortest-len))
        (apply
          proc
          index
          (map (cut flexvector-ref <> index) vecs)))))
  (define (flexvector-for-each proc fv . rest)
    (define (ignore-index . args) (apply proc (cdr args)))
    (apply flexvector-for-each/index ignore-index fv rest))
  (define (flexvector-count pred? fv . rest)
    (with-shortest-length
      ((vecs shortest-len) (cons fv rest))
      (let loop ([index 0] [count 0])
        (cond
          [(>= index shortest-len) count]
          [(apply pred? (map (cut flexvector-ref <> index) vecs))
           (loop (+ index 1) (+ count 1))]
          [else (loop (+ index 1) count)]))))
  (define (flexvector-cumulate reductor initial fv)
    (with-flexvectors
      (((vec len) fv))
      (let* ([result (make-flexvector len)]
             [new-vec (flexvector-vec result)])
        (let loop ([index 0] [state initial])
          (cond
            [(>= index len) result]
            [else
             (let ([new-state (reductor state (vector-ref vec index))])
               (vector-set! new-vec index new-state)
               (loop (+ index 1) new-state))])))))
  (define (flexvector-index pred? fv . rest)
    (with-shortest-length
      ((vecs shortest-len) (cons fv rest))
      (let loop ([index 0])
        (cond
          [(>= index shortest-len) #f]
          [(apply pred? (map (cut flexvector-ref <> index) vecs))
           index]
          [else (loop (+ index 1))]))))
  (define (flexvector-index-right pred? fv . rest)
    (with-shortest-length
      ((vecs shortest-len) (cons fv rest))
      (let loop ([index 0])
        (cond
          [(>= index shortest-len) #f]
          [(apply
             pred?
             (map (cut flexvector-ref <> (- shortest-len index 1)) vecs))
           (- shortest-len index 1)]
          [else (loop (+ index 1))]))))
  (define (flexvector-skip pred? fv . rest)
    (apply flexvector-index (negate pred?) fv rest))
  (define (flexvector-skip-right pred? fv . rest)
    (apply flexvector-index-right (negate pred?) fv rest))
  (define-with-range
    (flexvector-binary-search fv value comp start (end of fv))
    (let ([vec (flexvector-vec fv)])
      (vector-binary-search vec value comp start end)))
  (define (flexvector-any pred? fv . rest)
    (with-shortest-length
      ((vecs shortest-len) (cons fv rest))
      (let loop ([index 0])
        (cond
          [(>= index shortest-len) #f]
          [(apply pred? (map (cut flexvector-ref <> index) vecs))]
          [else (loop (+ index 1))]))))
  (define (flexvector-every pred? fv . rest)
    (with-shortest-length
      ((vecs shortest-len) (cons fv rest))
      (let loop ([index 0] [last-value #t])
        (cond
          [(>= index shortest-len) last-value]
          [(apply pred? (map (cut flexvector-ref <> index) vecs)) =>
           (lambda (val) (loop (+ index 1) val))]
          [else #f]))))
  (define (flexvector-partition pred? fv)
    (let ([matching (flexvector)] [non-matching (flexvector)])
      (flexvector-for-each
        (lambda (el)
          (flexvector-add-back!
            (if (pred? el) matching non-matching)
            el))
        fv)
      (values matching non-matching)))
  (define-with-range
    (flexvector->vector fv start (end of fv))
    (let ([vec (flexvector-vec fv)])
      (vector-copy vec start end)))
  (define vector->flexvector
    (case-lambda
      [(vec) (vector->flexvector vec 0)]
      [(vec start)
       (vector->flexvector vec start (vector-length vec))]
      [(vec start end)
       (let* ([len (- end start)]
              [result (make-flexvector len)]
              [fvec (flexvector-vec result)])
         (vector-copy! fvec 0 vec start end)
         result)]))
  (define (flexvector->list-impl finalizer fv start end)
    (with-flexvectors
      (((vec len) fv))
      (let loop ([acc (list)] [index 0])
        (cond
          [(>= index len) (finalizer acc)]
          [else
           (loop (cons (vector-ref vec index) acc) (+ index 1))]))))
  (define-with-range
    (flexvector->list fv start (end of fv))
    (flexvector->list-impl reverse fv start end))
  (define-with-range
    (reverse-flexvector->list fv start (end of fv))
    (define (identity l) l)
    (flexvector->list-impl identity fv start end))
  (define (list->flexvector-impl lst index-func)
    (let* ([len (length lst)] [fv (make-flexvector len)])
      (let loop ([lst lst] [index 0])
        (cond
          [(null? lst) fv]
          [else
           (flexvector-set! fv (index-func len index) (car lst))
           (loop (cdr lst) (+ index 1))]))))
  (define (list->flexvector lst)
    (list->flexvector-impl lst (lambda (len index) index)))
  (define (reverse-list->flexvector lst)
    (list->flexvector-impl
      lst
      (lambda (len index) (- len index 1))))
  (define-with-range
    (flexvector->string fv start (end of fv))
    (let-values ([(out fin) (open-string-output-port)])
      (with-flexvectors
        (((vec len) fv))
        (let loop ([index start])
          (cond
            [(>= index end) (fin)]
            [else
             (put-char out (vector-ref vec index))
             (loop (+ index 1))])))))
  (define string->flexvector
    (case-lambda
      [(str) (string->flexvector str 0)]
      [(str start)
       (string->flexvector str start (string-length str))]
      [(str start end)
       (let ([in (open-string-input-port
                   (substring str start end))]
             [fv (flexvector)])
         (let loop ([ch (get-char in)])
           (cond
             [(eof-object? ch) fv]
             [else
              (flexvector-add-back! fv ch)
              (loop (get-char in))])))]))
  (define (flexvector->generator fv)
    (with-flexvectors
      (((vec len) fv))
      (let ([index 0])
        (lambda ()
          (cond
            [(>= index len) (eof-object)]
            [else
             (let ([value (vector-ref vec index)])
               (set! index (+ index 1))
               value)])))))
  (define (generator->flexvector gen)
    (let ([fv (flexvector)])
      (generator-fold
        (lambda (v r) (flexvector-add-back! r v))
        fv
        gen))))
