;; DO NOT EDIT THIS FILE!!
;; This inlined chez-srfi library code is autogenerated using command:
;; $ ./install.chezscheme.sps ../vendor
;; Source origin: https://github.com/arcfide/chez-srfi
;; Please refer to project site for full credits and original code.
;;;;;; File header: %3a27/random-bits.sls
#!r6rs
;; Copyright 2010 Derick Eddington.  My MIT-style license is in the file named
;; LICENSE from the original collection this file is distributed with.
;;;;;; File header: %3a27/mrg32k3a-a.scm
; 54-BIT INTEGER IMPLEMENTATION OF THE "MRG32K3A"-GENERATOR
; =========================================================
;
; Sebastian.Egner@philips.com, Mar-2002.
;
; This file is an implementation of Pierre L'Ecuyer's MRG32k3a
; pseudo random number generator. Please refer to 'mrg32k3a.scm'
; for more information.
;
; compliance:
;   Scheme R5RS with integers covering at least {-2^53..2^53-1}.
;
; history of this file:
;   SE, 18-Mar-2002: initial version
;   SE, 22-Mar-2002: comments adjusted, range added
;   SE, 25-Mar-2002: pack/unpack just return their argument
;;;;;; File header: %3a27/mrg32k3a.scm
; GENERIC PART OF MRG32k3a-GENERATOR FOR SRFI-27
; ==============================================
;
; Sebastian.Egner@philips.com, 2002.
;
; This is the generic R5RS-part of the implementation of the MRG32k3a
; generator to be used in SRFI-27. It is based on a separate implementation
; of the core generator (presumably in native code) and on code to
; provide essential functionality not available in R5RS (see below).
;
; compliance:
;   Scheme R5RS with integer covering at least {-2^53..2^53-1}.
;   In addition,
;     SRFI-23: error
;
; history of this file:
;   SE, 22-Mar-2002: refactored from earlier versions
;   SE, 25-Mar-2002: pack/unpack need not allocate
;   SE, 27-Mar-2002: changed interface to core generator
;   SE, 10-Apr-2002: updated spec of mrg32k3a-random-integer
(library (purs runtime srfi :27 random-bits)
  (export random-integer random-real default-random-source
    make-random-source random-source? random-source-state-ref
    random-source-state-set! random-source-randomize!
    random-source-pseudo-randomize! random-source-make-integers
    random-source-make-reals)
  (import (rnrs) (rnrs r5rs)
    (only (purs runtime srfi :19 time) current-time time-nanosecond)
    (purs runtime srfi :23 error tricks) (purs runtime srfi private include))
  (define-record-type (:random-source
                        :random-source-make
                        :random-source?)
    (fields state-ref state-set! randomize! pseudo-randomize!
      make-integers make-reals))
  (define (:random-source-current-time)
    (time-nanosecond (current-time)))
  (SRFI-23-error->R6RS
    "(library (purs runtime srfi :27 random-bits))"
    (begin
      (define (mrg32k3a-random-m1 state)
        (let ([x11 (vector-ref state 0)]
              [x12 (vector-ref state 1)]
              [x13 (vector-ref state 2)]
              [x21 (vector-ref state 3)]
              [x22 (vector-ref state 4)]
              [x23 (vector-ref state 5)])
          (let ([x10 (modulo
                       (- (* 1403580 x12) (* 810728 x13))
                       4294967087)]
                [x20 (modulo
                       (- (* 527612 x21) (* 1370589 x23))
                       4294944443)])
            (vector-set! state 0 x10)
            (vector-set! state 1 x11)
            (vector-set! state 2 x12)
            (vector-set! state 3 x20)
            (vector-set! state 4 x21)
            (vector-set! state 5 x22)
            (modulo (- x10 x20) 4294967087))))
      (define (mrg32k3a-pack-state unpacked-state) unpacked-state)
      (define (mrg32k3a-unpack-state state) state)
      (define (mrg32k3a-random-range) 4294967087)
      (define (mrg32k3a-random-integer state range)
        (let* ([q (quotient 4294967087 range)] [qn (* q range)])
          (do ([x (mrg32k3a-random-m1 state) (mrg32k3a-random-m1
                                               state)])
              ((< x qn) (quotient x q)))))
      (define (mrg32k3a-random-real state)
        (* 2.328306549295728e-10
           (+ 1.0 (mrg32k3a-random-m1 state)))))
    (begin
      (define (mrg32k3a-state-ref packed-state)
        (cons
          'lecuyer-mrg32k3a
          (vector->list (mrg32k3a-unpack-state packed-state))))
      (define (mrg32k3a-state-set external-state)
        (define (check-value x m)
          (if (and (integer? x) (exact? x) (<= 0 x (- m 1)))
              #t
              (error "illegal value" x)))
        (if (and (list? external-state)
                 (= (length external-state) 7)
                 (eq? (car external-state) 'lecuyer-mrg32k3a))
            (let ([s (cdr external-state)])
              (check-value (list-ref s 0) mrg32k3a-m1)
              (check-value (list-ref s 1) mrg32k3a-m1)
              (check-value (list-ref s 2) mrg32k3a-m1)
              (check-value (list-ref s 3) mrg32k3a-m2)
              (check-value (list-ref s 4) mrg32k3a-m2)
              (check-value (list-ref s 5) mrg32k3a-m2)
              (if (or (zero?
                        (+ (list-ref s 0) (list-ref s 1) (list-ref s 2)))
                      (zero?
                        (+ (list-ref s 3) (list-ref s 4) (list-ref s 5))))
                  (error "illegal degenerate state" external-state))
              (mrg32k3a-pack-state (list->vector s)))
            (error "malformed state" external-state)))
      (define mrg32k3a-m1 4294967087)
      (define mrg32k3a-m2 4294944443)
      (define mrg32k3a-initial-state
        '#(1062452522 2961816100 342112271 2854655037 3321940838
           3542344109))
      (define mrg32k3a-generators #f)
      (define (mrg32k3a-pseudo-randomize-state i j)
        (define (product A B)
          (define w 65536)
          (define w-sqr1 209)
          (define w-sqr2 22853)
          (define (lc i0 i1 i2 j0 j1 j2 m w-sqr)
            (let ([a0h (quotient (vector-ref A i0) w)]
                  [a0l (modulo (vector-ref A i0) w)]
                  [a1h (quotient (vector-ref A i1) w)]
                  [a1l (modulo (vector-ref A i1) w)]
                  [a2h (quotient (vector-ref A i2) w)]
                  [a2l (modulo (vector-ref A i2) w)]
                  [b0h (quotient (vector-ref B j0) w)]
                  [b0l (modulo (vector-ref B j0) w)]
                  [b1h (quotient (vector-ref B j1) w)]
                  [b1l (modulo (vector-ref B j1) w)]
                  [b2h (quotient (vector-ref B j2) w)]
                  [b2l (modulo (vector-ref B j2) w)])
              (modulo
                (+ (* (+ (* a0h b0h) (* a1h b1h) (* a2h b2h)) w-sqr)
                   (* (+ (* a0h b0l) (* a0l b0h) (* a1h b1l) (* a1l b1h)
                         (* a2h b2l) (* a2l b2h))
                      w)
                   (* a0l b0l) (* a1l b1l) (* a2l b2l))
                m)))
          (vector (lc 0 1 2 0 3 6 mrg32k3a-m1 w-sqr1)
            (lc 0 1 2 1 4 7 mrg32k3a-m1 w-sqr1)
            (lc 0 1 2 2 5 8 mrg32k3a-m1 w-sqr1)
            (lc 3 4 5 0 3 6 mrg32k3a-m1 w-sqr1)
            (lc 3 4 5 1 4 7 mrg32k3a-m1 w-sqr1)
            (lc 3 4 5 2 5 8 mrg32k3a-m1 w-sqr1)
            (lc 6 7 8 0 3 6 mrg32k3a-m1 w-sqr1)
            (lc 6 7 8 1 4 7 mrg32k3a-m1 w-sqr1)
            (lc 6 7 8 2 5 8 mrg32k3a-m1 w-sqr1)
            (lc 9 10 11 9 12 15 mrg32k3a-m2 w-sqr2)
            (lc 9 10 11 10 13 16 mrg32k3a-m2 w-sqr2)
            (lc 9 10 11 11 14 17 mrg32k3a-m2 w-sqr2)
            (lc 12 13 14 9 12 15 mrg32k3a-m2 w-sqr2)
            (lc 12 13 14 10 13 16 mrg32k3a-m2 w-sqr2)
            (lc 12 13 14 11 14 17 mrg32k3a-m2 w-sqr2)
            (lc 15 16 17 9 12 15 mrg32k3a-m2 w-sqr2)
            (lc 15 16 17 10 13 16 mrg32k3a-m2 w-sqr2)
            (lc 15 16 17 11 14 17 mrg32k3a-m2 w-sqr2)))
        (define (power A e)
          (cond
            [(zero? e) '#(1 0 0 0 1 0 0 0 1 1 0 0 0 1 0 0 0 1)]
            [(= e 1) A]
            [(even? e) (power (product A A) (quotient e 2))]
            [else (product (power A (- e 1)) A)]))
        (define (power-power A b)
          (if (zero? b) A (power-power (product A A) (- b 1))))
        (define A
          '#(0 1403580 4294156359 1 0 0 0 1 0 527612 0 4293573854 1 0
             0 0 1 0))
        (if (not (and (integer? i)
                      (exact? i)
                      (integer? j)
                      (exact? j)))
            (error "i j must be exact integer" i j))
        (if (not mrg32k3a-generators)
            (set! mrg32k3a-generators
              (list (power-power A 127) (power-power A 76) (power A 16))))
        (let ([M (product
                   (list-ref mrg32k3a-generators 2)
                   (product
                     (power
                       (list-ref mrg32k3a-generators 0)
                       (modulo i (expt 2 28)))
                     (power
                       (list-ref mrg32k3a-generators 1)
                       (modulo j (expt 2 28)))))])
          (mrg32k3a-pack-state
            (vector (vector-ref M 0) (vector-ref M 3) (vector-ref M 6)
              (vector-ref M 9) (vector-ref M 12) (vector-ref M 15)))))
      (define (mrg32k3a-randomize-state state)
        (let* ([m 65536]
               [x (modulo (:random-source-current-time) m)])
          (define (random-m)
            (let ([y (modulo x m)])
              (set! x (+ (* 30903 y) (quotient x m)))
              y))
          (define (random n)
            (modulo (+ (* (random-m) m) (random-m)) n))
          (let ([m1 mrg32k3a-m1]
                [m2 mrg32k3a-m2]
                [s (mrg32k3a-unpack-state state)])
            (mrg32k3a-pack-state
              (vector
                (+ 1
                   (modulo
                     (+ (vector-ref s 0) (random (- m1 1)))
                     (- m1 1)))
                (modulo (+ (vector-ref s 1) (random m1)) m1)
                (modulo (+ (vector-ref s 2) (random m1)) m1)
                (+ 1
                   (modulo
                     (+ (vector-ref s 3) (random (- m2 1)))
                     (- m2 1)))
                (modulo (+ (vector-ref s 4) (random m2)) m2)
                (modulo (+ (vector-ref s 5) (random m2)) m2))))))
      (define mrg32k3a-m-max (mrg32k3a-random-range))
      (define (mrg32k3a-random-power state k)
        (if (= k 1)
            (mrg32k3a-random-integer state mrg32k3a-m-max)
            (+ (* (mrg32k3a-random-power state (- k 1)) mrg32k3a-m-max)
               (mrg32k3a-random-integer state mrg32k3a-m-max))))
      (define (mrg32k3a-random-large state n)
        (do ([k 2 (+ k 1)]
             [mk (* mrg32k3a-m-max mrg32k3a-m-max) (* mk
                                                      mrg32k3a-m-max)])
            ((>= mk n)
             (let* ([mk-by-n (quotient mk n)] [a (* mk-by-n n)])
               (do ([x (mrg32k3a-random-power state k) (mrg32k3a-random-power
                                                         state
                                                         k)])
                   ((< x a) (quotient x mk-by-n)))))))
      (define (mrg32k3a-random-real-mp state unit)
        (do ([k 1 (+ k 1)] [u (- (/ 1 unit) 1) (/ u mrg32k3a-m1)])
            ((<= u 1)
             (/ (exact->inexact (+ (mrg32k3a-random-power state k) 1))
                (exact->inexact (+ (expt mrg32k3a-m-max k) 1))))))
      (define (make-random-source)
        (let ([state (mrg32k3a-pack-state
                       (list->vector
                         (vector->list mrg32k3a-initial-state)))])
          (:random-source-make (lambda () (mrg32k3a-state-ref state))
            (lambda (new-state)
              (set! state (mrg32k3a-state-set new-state)))
            (lambda () (set! state (mrg32k3a-randomize-state state)))
            (lambda (i j)
              (set! state (mrg32k3a-pseudo-randomize-state i j)))
            (lambda ()
              (lambda (n)
                (cond
                  [(not (and (integer? n) (exact? n) (positive? n)))
                   (error "range must be exact positive integer" n)]
                  [(<= n mrg32k3a-m-max) (mrg32k3a-random-integer state n)]
                  [else (mrg32k3a-random-large state n)])))
            (lambda args
              (cond
                [(null? args) (lambda () (mrg32k3a-random-real state))]
                [(null? (cdr args))
                 (let ([unit (car args)])
                   (cond
                     [(not (and (real? unit) (< 0 unit 1)))
                      (error "unit must be real in (0,1)" unit)]
                     [(<= (- (/ 1 unit) 1) mrg32k3a-m1)
                      (lambda () (mrg32k3a-random-real state))]
                     [else
                      (lambda () (mrg32k3a-random-real-mp state unit))]))]
                [else (error "illegal arguments" args)])))))
      (define random-source? :random-source?)
      (define (random-source-state-ref s)
        ((:random-source-state-ref s)))
      (define (random-source-state-set! s state)
        ((:random-source-state-set! s) state))
      (define (random-source-randomize! s)
        ((:random-source-randomize! s)))
      (define (random-source-pseudo-randomize! s i j)
        ((:random-source-pseudo-randomize! s) i j))
      (define (random-source-make-integers s)
        ((:random-source-make-integers s)))
      (define (random-source-make-reals s . unit)
        (apply (:random-source-make-reals s) unit))
      (define default-random-source (make-random-source))
      (define random-integer
        (random-source-make-integers default-random-source))
      (define random-real
        (random-source-make-reals default-random-source)))))
